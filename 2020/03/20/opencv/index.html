<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>OpenCV入门笔记 | Zhu Junchao&#39;s Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="python,OpenCV">
    <meta name="description" content="图像基础读取图像cv2.read(image file, parms) 读取路径的图片     prams value description     cv2.IMREAD_COLOR 1 读入彩色图像，忽略图像透明度   cv2.IMREAD_GRAYSCALE 0 以灰度模式读入图像   cv2.IMREAD_UNCHANGED -1 读入一幅图像，包括图像的alpha通道     显示图像​">
<meta name="keywords" content="python,OpenCV">
<meta property="og:type" content="article">
<meta property="og:title" content="OpenCV入门笔记">
<meta property="og:url" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;2020&#x2F;03&#x2F;20&#x2F;opencv&#x2F;index.html">
<meta property="og:site_name" content="Zhu Junchao&#39;s Blog">
<meta property="og:description" content="图像基础读取图像cv2.read(image file, parms) 读取路径的图片     prams value description     cv2.IMREAD_COLOR 1 读入彩色图像，忽略图像透明度   cv2.IMREAD_GRAYSCALE 0 以灰度模式读入图像   cv2.IMREAD_UNCHANGED -1 读入一幅图像，包括图像的alpha通道     显示图像​">
<meta property="og:locale" content="en">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;draw.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;trans.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;rotation.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;affine.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;simthresh.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;adtthresh.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;blur.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;op.png">
<meta property="og:image" content="http:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;xtx.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;cannyhold.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;mnthresh.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;canny.png">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;blending.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;caprox.webp">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;tb.webp">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;rc.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;cmc.jpg">
<meta property="og:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;cl.jpg">
<meta property="og:updated_time" content="2021-04-16T17:24:28.510Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;pllj.github.io&#x2F;img&#x2F;opencv&#x2F;draw.png">
    
    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
	<link rel="stylesheet" href="https://pllj.github.io/css/mystyle.css">
    <script>window.lazyScripts=[]</script>
	<script src="https://apps.bdimg.com/libs/jquery/2.1.4/jquery.min.js"></script>
    <!-- custom head -->
    

</head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" target="_self" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/brand.jpg)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/main.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Zhu Junchao</h5>
          <a href="mailto:1169614863@qq.com" target="_blank" rel="noopener" title="1169614863@qq.com" class="mail">1169614863@qq.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                主页
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/pllj" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/custom"  >
                <i class="icon icon-lg icon-link"></i>
                测试
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" target="_self" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">OpenCV入门笔记</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" target="_self" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="Search">
            <a href="javascript:;" target="_self" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" target="_self" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">OpenCV入门笔记</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-20T05:55:43.000Z" itemprop="datePublished" class="page-time">
  2020-03-20
</time>


            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#图像基础"><span class="post-toc-number">1.</span> <span class="post-toc-text">图像基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#读取图像"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">读取图像</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#显示图像"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">显示图像</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#保存图像"><span class="post-toc-number">1.3.</span> <span class="post-toc-text">保存图像</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#总结"><span class="post-toc-number">1.4.</span> <span class="post-toc-text">总结</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用matplotlib"><span class="post-toc-number">1.4.1.</span> <span class="post-toc-text">使用matplotlib</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#视频基础"><span class="post-toc-number">2.</span> <span class="post-toc-text">视频基础</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#摄像头捕获视频"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">摄像头捕获视频</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#从文件中播放视频"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">从文件中播放视频</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#保存视频"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">保存视频</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#OpenCV绘图函数"><span class="post-toc-number">3.</span> <span class="post-toc-text">OpenCV绘图函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#画线"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">画线</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#画矩形"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">画矩形</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#画圆"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">画圆</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#画椭圆"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">画椭圆</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#画多边形"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">画多边形</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#在图片上添加文字"><span class="post-toc-number">3.6.</span> <span class="post-toc-text">在图片上添加文字</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#最终效果"><span class="post-toc-number">3.7.</span> <span class="post-toc-text">最终效果</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#鼠标当画笔"><span class="post-toc-number">4.</span> <span class="post-toc-text">鼠标当画笔</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#滑动条做调色板"><span class="post-toc-number">5.</span> <span class="post-toc-text">滑动条做调色板</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#图像的基础操作"><span class="post-toc-number">6.</span> <span class="post-toc-text">图像的基础操作</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#获取并修改像素值"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">获取并修改像素值</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#获取图像属性"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">获取图像属性</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#图像ROI"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">图像ROI</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#拆分及合并图像通道"><span class="post-toc-number">6.4.</span> <span class="post-toc-text">拆分及合并图像通道</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#为图像扩边（填充）"><span class="post-toc-number">6.5.</span> <span class="post-toc-text">为图像扩边（填充）</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#图像上的-算术运算"><span class="post-toc-number">6.6.</span> <span class="post-toc-text">图像上的 算术运算</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#图像加法"><span class="post-toc-number">6.6.1.</span> <span class="post-toc-text">图像加法</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#图像混合"><span class="post-toc-number">6.6.2.</span> <span class="post-toc-text">图像混合</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#按位运算"><span class="post-toc-number">6.6.3.</span> <span class="post-toc-text">按位运算</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#程序性能检测及优化"><span class="post-toc-number">6.7.</span> <span class="post-toc-text">程序性能检测及优化</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用-OpenCV-检测程序效率"><span class="post-toc-number">6.7.1.</span> <span class="post-toc-text">使用 OpenCV 检测程序效率</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#OpenCV的默认优化"><span class="post-toc-number">6.7.2.</span> <span class="post-toc-text">OpenCV的默认优化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#在-IPython-中检测程序效率"><span class="post-toc-number">6.7.3.</span> <span class="post-toc-text">在 $IPython$ 中检测程序效率</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#更多-IPython-的魔法命令"><span class="post-toc-number">6.7.4.</span> <span class="post-toc-text">更多 $IPython$ 的魔法命令</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#效率优化技术"><span class="post-toc-number">6.7.5.</span> <span class="post-toc-text">效率优化技术</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OpenCV-中的数学工具"><span class="post-toc-number">6.8.</span> <span class="post-toc-text">OpenCV 中的数学工具</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#OpenCV-中的图像处理"><span class="post-toc-number">7.</span> <span class="post-toc-text">OpenCV 中的图像处理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#颜色空间转换"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">颜色空间转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#转换颜色空间"><span class="post-toc-number">7.1.1.</span> <span class="post-toc-text">转换颜色空间</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#物体跟踪"><span class="post-toc-number">7.1.2.</span> <span class="post-toc-text">物体跟踪</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#找到要跟踪对象的-HSV-值"><span class="post-toc-number">7.1.3.</span> <span class="post-toc-text">找到要跟踪对象的 $HSV$ 值</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#几何变换"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">几何变换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#扩展缩放"><span class="post-toc-number">7.2.1.</span> <span class="post-toc-text">扩展缩放</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#平移"><span class="post-toc-number">7.2.2.</span> <span class="post-toc-text">平移</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#旋转"><span class="post-toc-number">7.2.3.</span> <span class="post-toc-text">旋转</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#仿射变换"><span class="post-toc-number">7.2.4.</span> <span class="post-toc-text">仿射变换</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#透视变换"><span class="post-toc-number">7.2.5.</span> <span class="post-toc-text">透视变换</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#图像阈值"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">图像阈值</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#简单阈值"><span class="post-toc-number">7.3.1.</span> <span class="post-toc-text">简单阈值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#自适应阈值"><span class="post-toc-number">7.3.2.</span> <span class="post-toc-text">自适应阈值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Otsu’s-二值化"><span class="post-toc-number">7.3.3.</span> <span class="post-toc-text">$Otsu’s$ 二值化</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#otsu-工作原理"><span class="post-toc-number">7.3.4.</span> <span class="post-toc-text">$otsu$工作原理</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#图像平滑"><span class="post-toc-number">7.4.</span> <span class="post-toc-text">图像平滑</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2D-卷积"><span class="post-toc-number">7.4.1.</span> <span class="post-toc-text">$2D$卷积</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#图像模糊（图像平滑）"><span class="post-toc-number">7.4.2.</span> <span class="post-toc-text">图像模糊（图像平滑）</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#平均"><span class="post-toc-number">7.4.2.1.</span> <span class="post-toc-text">平均</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#高斯模糊"><span class="post-toc-number">7.4.2.2.</span> <span class="post-toc-text">高斯模糊</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#中值模糊"><span class="post-toc-number">7.4.2.3.</span> <span class="post-toc-text">中值模糊</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#双边滤波"><span class="post-toc-number">7.4.2.4.</span> <span class="post-toc-text">双边滤波</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#形态学转换"><span class="post-toc-number">7.5.</span> <span class="post-toc-text">形态学转换</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#腐蚀"><span class="post-toc-number">7.5.1.</span> <span class="post-toc-text">腐蚀</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#膨胀"><span class="post-toc-number">7.5.2.</span> <span class="post-toc-text">膨胀</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#开运算"><span class="post-toc-number">7.5.3.</span> <span class="post-toc-text">开运算</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#闭运算"><span class="post-toc-number">7.5.4.</span> <span class="post-toc-text">闭运算</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#形态学梯度"><span class="post-toc-number">7.5.5.</span> <span class="post-toc-text">形态学梯度</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#礼帽"><span class="post-toc-number">7.5.6.</span> <span class="post-toc-text">礼帽</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#黑帽"><span class="post-toc-number">7.5.7.</span> <span class="post-toc-text">黑帽</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#形态学操作之间的关系"><span class="post-toc-number">7.5.8.</span> <span class="post-toc-text">形态学操作之间的关系</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#结构化元素"><span class="post-toc-number">7.5.9.</span> <span class="post-toc-text">结构化元素</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#图像梯度"><span class="post-toc-number">7.6.</span> <span class="post-toc-text">图像梯度</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Sobel-算子和-Scharr-算子"><span class="post-toc-number">7.6.1.</span> <span class="post-toc-text">$Sobel$ 算子和 $Scharr$ 算子</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Laplacian-算子"><span class="post-toc-number">7.6.2.</span> <span class="post-toc-text">$Laplacian$ 算子</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Canny边缘检测"><span class="post-toc-number">7.7.</span> <span class="post-toc-text">Canny边缘检测</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#噪声去除"><span class="post-toc-number">7.7.1.</span> <span class="post-toc-text">噪声去除</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#计算图像梯度"><span class="post-toc-number">7.7.2.</span> <span class="post-toc-text">计算图像梯度</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#非极大值抑制"><span class="post-toc-number">7.7.3.</span> <span class="post-toc-text">非极大值抑制</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#滞后阈值"><span class="post-toc-number">7.7.4.</span> <span class="post-toc-text">滞后阈值</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#OpenCV-中的-Canny-边界检测"><span class="post-toc-number">7.7.5.</span> <span class="post-toc-text">OpenCV 中的 Canny 边界检测</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#图像金字塔"><span class="post-toc-number">7.8.</span> <span class="post-toc-text">图像金字塔</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#原理"><span class="post-toc-number">7.8.1.</span> <span class="post-toc-text">原理</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#使用金字塔进行图像融合"><span class="post-toc-number">7.8.2.</span> <span class="post-toc-text">使用金字塔进行图像融合</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#OpenCV-中的轮廓"><span class="post-toc-number">7.9.</span> <span class="post-toc-text">OpenCV 中的轮廓</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#什么是轮廓"><span class="post-toc-number">7.9.1.</span> <span class="post-toc-text">什么是轮廓</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#怎样绘制轮廓"><span class="post-toc-number">7.9.2.</span> <span class="post-toc-text">怎样绘制轮廓</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#轮廓的近似方法"><span class="post-toc-number">7.9.3.</span> <span class="post-toc-text">轮廓的近似方法</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#轮廓特征"><span class="post-toc-number">7.10.</span> <span class="post-toc-text">轮廓特征</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#矩"><span class="post-toc-number">7.10.1.</span> <span class="post-toc-text">矩</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#轮廓面积"><span class="post-toc-number">7.10.2.</span> <span class="post-toc-text">轮廓面积</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#轮廓周长"><span class="post-toc-number">7.10.3.</span> <span class="post-toc-text">轮廓周长</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#轮廓近似"><span class="post-toc-number">7.10.4.</span> <span class="post-toc-text">轮廓近似</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#凸包"><span class="post-toc-number">7.10.5.</span> <span class="post-toc-text">凸包</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#凸性检测"><span class="post-toc-number">7.10.6.</span> <span class="post-toc-text">凸性检测</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#边界矩形"><span class="post-toc-number">7.10.7.</span> <span class="post-toc-text">边界矩形</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#最小外接圆"><span class="post-toc-number">7.10.8.</span> <span class="post-toc-text">最小外接圆</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#椭圆拟合"><span class="post-toc-number">7.10.9.</span> <span class="post-toc-text">椭圆拟合</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#直线拟合"><span class="post-toc-number">7.10.10.</span> <span class="post-toc-text">直线拟合</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#轮廓的性质"><span class="post-toc-number">7.11.</span> <span class="post-toc-text">轮廓的性质</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#长宽比"><span class="post-toc-number">7.11.0.1.</span> <span class="post-toc-text">长宽比</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Extent"><span class="post-toc-number">7.11.0.2.</span> <span class="post-toc-text">Extent</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Solidity"><span class="post-toc-number">7.11.0.3.</span> <span class="post-toc-text">Solidity</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#Equivalent-Diameter"><span class="post-toc-number">7.11.0.4.</span> <span class="post-toc-text">Equivalent Diameter</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#方向"><span class="post-toc-number">7.11.0.5.</span> <span class="post-toc-text">方向</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#掩模和像素点"><span class="post-toc-number">7.11.0.6.</span> <span class="post-toc-text">掩模和像素点</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#最大值和最小值及它们的位置"><span class="post-toc-number">7.11.0.7.</span> <span class="post-toc-text">最大值和最小值及它们的位置</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#平均颜色及平均灰度"><span class="post-toc-number">7.11.0.8.</span> <span class="post-toc-text">平均颜色及平均灰度</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#极点"><span class="post-toc-number">7.11.0.9.</span> <span class="post-toc-text">极点</span></a></li></ol></li></ol></li></ol></li></ol>
        </nav>
    </aside>


<article id="post-opencv"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">OpenCV入门笔记</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-20 13:55:43" datetime="2020-03-20T05:55:43.000Z"  itemprop="datePublished">2020-03-20</time>

            


            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>
</span>


        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <h2 id="图像基础"><a href="#图像基础" class="headerlink" title="图像基础"></a>图像基础</h2><h3 id="读取图像"><a href="#读取图像" class="headerlink" title="读取图像"></a>读取图像</h3><p><strong><code>cv2.read(image file, parms)</code></strong> 读取路径的图片</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>prams</th>
<th>value</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv2.IMREAD_COLOR</code></td>
<td>1</td>
<td>读入彩色图像，忽略图像透明度</td>
</tr>
<tr>
<td><code>cv2.IMREAD_GRAYSCALE</code></td>
<td>0</td>
<td>以灰度模式读入图像</td>
</tr>
<tr>
<td><code>cv2.IMREAD_UNCHANGED</code></td>
<td>-1</td>
<td>读入一幅图像，包括图像的alpha通道</td>
</tr>
</tbody>
</table>
</div>
<h3 id="显示图像"><a href="#显示图像" class="headerlink" title="显示图像"></a>显示图像</h3><p>​        使用函数<code>cv2.imshow()</code> 显示图像。窗口会自动调整为图像大小。第一 个参数是窗口的名字，其次才是我们的图像。你可以创建多个窗口，只要你喜欢，但是必须给他们不同的名字。</p>
<p>​        <code>cv2.waitKey()</code>是一个键盘绑定函数。需要指出的是它的时间尺度是<strong>毫秒级</strong>。函数等待特定的几毫秒，看是否有键盘输入。特定的几毫秒之内，如果按下任意键，这个函数会返回按键的 ASCII 码值，程序将会继续运行。如果没有键盘输入，返回值为 -1，如果设置这个函数的参数为0，那它将会无限期的等待键盘输入。它也可以被用来检测特定键是否被按下，例如按键 a 是否 被按下。</p>
<p>​        <code>cv2.destroyAllWindows()</code> 可以轻易删除任何我们建立的窗口。如果你想删除特定的窗口可以使用 <code>cv2.destroyWindow()</code>，在括号内输入你想删除的窗口名。</p>
<p><strong>建议</strong>：<em>一种特殊的情况是先创建窗口再加载图像。这种情况下可以决定窗口是否可以调整大小。使用的函数是 <code>cv2.namedWindow()</code>。初始设定函数标签是 <code>cv2.WINDOW_AUTOSIZE</code>。如果把标签改 成<code>cv2.WINDOW_NORMAL</code>，就可以调整窗口大小了。当图像维度太大或者要添加轨迹条时，调整窗口大小将会很有用。</em></p>
<h3 id="保存图像"><a href="#保存图像" class="headerlink" title="保存图像"></a>保存图像</h3><p>​        使用函数 <code>cv2.imwrite()</code> 来保存一个图像。首先需要一个文件名，之后才 是你要保存的图像。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"material/5.jpg"</span>,<span class="number">-1</span>) <span class="comment">#读取路径下的图像</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">"image"</span>,cv2.WINDOW_NORMAL) <span class="comment">#先建立一个窗口，并设置标签为WINDOW_NORMAL以调整窗口大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"image"</span>, img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">'messigray.png'</span>,img) <span class="comment">#将图片以PNG格式保存</span></span></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​        下面的程序将会加载一个灰度图，显示图片，按下$’s’$键保存后退出，或者 按下 $ESC$ 键退出不保存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'messi5.jpg'</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">k = cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k == <span class="number">27</span>: <span class="comment"># wait for ESC key to exit</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">elif</span> k == ord(<span class="string">'s'</span>): <span class="comment"># wait for 's' key to save and exit</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">'messigray.png'</span>,img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<p><strong>警告：</strong> <em>64 位系统需要将  <code>k = cv2.waitKey(0)</code> 这行改成 <code>k = cv2.waitKey(0)&amp;0xFF</code>。</em></p>
<h4 id="使用matplotlib"><a href="#使用matplotlib" class="headerlink" title="使用matplotlib"></a>使用matplotlib</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#读取图片</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'material/5.jpg'</span>,<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#将图片由GBR模式转换回RGB模式</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">b,g,r = cv2.split(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">img2 = cv2.merge([r,g,b])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#用matplotlib输出</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">plt.imshow(img2, cmap = <span class="string">'gray'</span>, interpolation = <span class="string">'bicubic'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">plt.xticks([]), plt.yticks([]) <span class="comment"># to hide tick values on X and Y axis</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<p><strong>注意：</strong> <em>彩色图像使用 $OpenCV$ 加载时是 $BGR$ 模式。但是 $Matplotib$ 是 $RGB$ 模式。所以彩色图像如果已经被 $OpenCV$ 读取，那它将不会被 $Matplotib$ 正确显示。</em></p>
<h2 id="视频基础"><a href="#视频基础" class="headerlink" title="视频基础"></a>视频基础</h2><h3 id="摄像头捕获视频"><a href="#摄像头捕获视频" class="headerlink" title="摄像头捕获视频"></a>摄像头捕获视频</h3><p>​        下面代码使用摄像头来捕获一段视频，并把它转换成灰度视频显示出来。</p>
<p>​        为了获取视频，你应该创建一个 $VideoCapture$ 对象。他的参数可以是<strong>设备的索引号</strong>，或者是一个<strong>视频文件</strong>。设备索引号就是在指定要使用的摄像头。 一般的笔记本电脑都有内置摄像头。所以参数就是$0$。你可以通过设置成 $1$或者其他的来选择别的摄像头。之后就可以一帧一帧的捕获视频了。但是最后，别忘了停止捕获视频。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建VideoCapture对象</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># Capture frame-by-frame</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    ret, frame = cap.read()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># Our operations on the frame come here</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># Display the resulting frame</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    cv2.imshow(<span class="string">'frame'</span>,gray)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># When everything done, release the capture</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">cap.release()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<p>​        <code>cap.read()</code>返回一个布尔值（$True/False$）。如果帧读取的是正确的， 就是 True。所以最后可以通过检查他的返回值来查看视频文件是否已经到 了结尾。</p>
<p>​        有时 $cap$ 可能不能成功初始化摄像头设备。这种情况下上面的代码会报错。你可以使用 <code>cap.isOpened()</code>来检查是否成功初始化了。如果返回值是 $True$，那就没有问题。否则就要使用函数 <code>cap.open()</code>。</p>
<p>​        可以使用函数 <code>cap.get(propId)</code> 来获得视频的一些参数信息。这里 $propId$ 可以是 $0$ 到 $18$ 之间的任何整数。每一个数代表视频的一个属性（见下表），其中的一些值可以使用 <code>cap.set(propId,value)</code> 来修改，$value$ 就是想要设置成的新值。 例如，可以使用 <code>cap.get(3)</code> 和 <code>cap.get(4)</code> 来查看每一帧的宽和高。默认情况下得到的值是 $640<em>480$。但是可以使用 <code>ret=cap.set(3,320)</code> 和 <code>ret=cap.set(4,240)</code> 来把宽和高改成 $320</em>240$。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>pram</th>
<th>define</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv2.VideoCapture.get(0)</code></td>
<td>视频文件的当前位置（播放）以毫秒为单位</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(1)</code></td>
<td>基于以0开始的被捕获或解码的帧索引</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(2)</code></td>
<td>视频文件的相对位置（播放）：0=电影开始，1=影片的结尾。</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(3)</code></td>
<td>在视频流的帧的宽度</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(4)</code></td>
<td>在视频流的帧的高度</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(5)</code></td>
<td>帧速率</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(6)</code></td>
<td>编解码的4字-字符代码</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(7)</code></td>
<td>视频文件中的帧数</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(8)</code></td>
<td>返回对象的格式</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(9)</code></td>
<td>返回后端特定的值，该值指示当前捕获模式</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(10)</code></td>
<td>图像的亮度(仅适用于照相机)</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(11)</code></td>
<td>图像的对比度(仅适用于照相机)</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(12)</code></td>
<td>图像的饱和度(仅适用于照相机)</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(13)</code></td>
<td>色调图像(仅适用于照相机)</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(14)</code></td>
<td>图像增益(仅适用于照相机)（Gain在摄影中表示白平衡提升）</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(15)</code></td>
<td>曝光(仅适用于照相机)</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(16)</code></td>
<td>指示是否应将图像转换为7$RGB$布尔标志</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(17)</code></td>
<td>× 暂时不支持</td>
</tr>
<tr>
<td><code>cv2.VideoCapture.get(18)</code></td>
<td>立体摄像机的矫正标注（目前只有$DC1394 v.2.x$后端支持这个功能）</td>
</tr>
</tbody>
</table>
</div>
<h3 id="从文件中播放视频"><a href="#从文件中播放视频" class="headerlink" title="从文件中播放视频"></a>从文件中播放视频</h3><p>​        与从摄像头中捕获一样，只需要把设备索引号改成视频文件的名字。在播放每一帧时，使用<code>cv2.waitKey()</code> 设置适当的持续时间。如果设置的太低视频就会播放的非常快，如果设置的太高就会播放的很慢（可以使用这种方法控制视频的播放速度）。通常情况下 <strong>25 毫秒</strong>就可以了。</p>
<h3 id="保存视频"><a href="#保存视频" class="headerlink" title="保存视频"></a>保存视频</h3><p>​        要创建一个 $VideoWriter$ 的对象。我们应该确定一个输出文件 的名字。接下来指定 $FourCC$ 编码（下面会介绍）。播放频率和帧的大小也都需要确定。最后一个是 $isColor$ 标签。如果是 $True$，每一帧就是彩色图，否则就是灰度图。 $FourCC$ 就是一个 4 字节码，用来确定视频的编码格式。可用的编码列表 可以从<a href="http://www.fourcc.org/codecs.php" target="_blank" rel="noopener">fourcc.org</a>查到。这是平台依赖的。下面这些编码器是比较常用的。 </p>
<ul>
<li><strong>In Fedora:</strong> <code>DIVX, XVID, MJPG, X264, WMV1, WMV2. (XVID is more preferable. MJPG results in high size video. X264 gives very small size video)</code></li>
<li><strong>In Windows</strong>: <code>DIVX (More to be tested and added)</code></li>
<li><strong>In OSX :</strong> <code>(I don’t have access to OSX. Can some one fill this?)</code>  </li>
</ul>
<p>$FourCC$ 码以下面的格式传给程序，以 $MJPG$ 为例： <code>cv2.cv.FOURCC(&#39;M&#39;,&#39;J&#39;,&#39;P&#39;,&#39;G&#39;)</code> 或者 <code>cv2.cv.FOURCC(\*&#39;MJPG&#39;)</code>。 </p>
<p>​        下面的代码是从摄像头中捕获视频，沿竖直方向旋转每一帧并保存它。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">cap = cv2.VideoCapture(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Define the codec and create VideoWriter object</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">fourcc = cv2.VideoWriter_fourcc(*<span class="string">'DIVX'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">out = cv2.VideoWriter(<span class="string">'e.avi'</span>,fourcc, <span class="number">20.0</span>, (<span class="number">640</span>,<span class="number">480</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(cap.isOpened()):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    ret, frame = cap.read()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> ret==<span class="literal">True</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        frame = cv2.flip(frame,<span class="number">1</span>) <span class="comment">#0为沿水平方向旋转，任意正数为沿竖直方向旋转，任意负数为同时 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># write the flipped frame</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        out.write(frame)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        cv2.imshow(<span class="string">'frame'</span>,frame)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == ord(<span class="string">'q'</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Release everything if job is finished</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">cap.release()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">out.release()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<h2 id="OpenCV绘图函数"><a href="#OpenCV绘图函数" class="headerlink" title="OpenCV绘图函数"></a>OpenCV绘图函数</h2><p>这些绘图函数需要设置下面这些参数：</p>
<ul>
<li>$img：$你想要绘制图形的那幅图像。</li>
<li>$color：$形状的颜色。以 $RGB$ 为例，需要传入一个元组，例如：$(255,0,0)$ 代表蓝色。对于灰度图只需要传入灰度值。</li>
<li>$thickness：$线条的粗细。如果给一个闭合图形设置为 $-1$，那么这个图形就会被填充。默认值是 $1$。</li>
<li>$linetype：$线条的类型，$8$连接，抗锯齿等。默认情况是 $8$ 连接。<code>cv2.LINE_AA</code> 为抗锯齿，这样看起来会非常平滑。</li>
</ul>
<h3 id="画线"><a href="#画线" class="headerlink" title="画线"></a>画线</h3><p>​        要画一条线，只需要告诉函数这条线的起点和终点。下面代码会画一条从左上方到右下角的蓝色线段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Create a black image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Draw a diagonal blue line with thickness of 5 px</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">cv2.line(img,(<span class="number">0</span>,<span class="number">0</span>),(<span class="number">511</span>,<span class="number">511</span>),(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Show the image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"img"</span>,img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<h3 id="画矩形"><a href="#画矩形" class="headerlink" title="画矩形"></a>画矩形</h3><p>​        要画一个矩形，你需要告诉函数的左上角顶点和右下角顶点的坐标。下面的代码会在图像的右上角画一个绿色的矩形。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cv2.rectangle(img,(<span class="number">384</span>,<span class="number">0</span>),(<span class="number">510</span>,<span class="number">128</span>),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">3</span>)</span></pre></td></tr></table></figure>
<h3 id="画圆"><a href="#画圆" class="headerlink" title="画圆"></a>画圆</h3><p>​        要画圆的话，只需要指定圆形的中心点坐标和半径大小。我们在上面的矩形中画一个圆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cv2.circle(img,(<span class="number">447</span>,<span class="number">63</span>),<span class="number">63</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">-1</span>)</span></pre></td></tr></table></figure>
<h3 id="画椭圆"><a href="#画椭圆" class="headerlink" title="画椭圆"></a>画椭圆</h3><p>​        画椭圆比较复杂，我们要多输入几个参数。一个参数是中心点的位置坐标。 下一个参数是长轴和短轴的长度。椭圆沿顺时针旋转的角度。椭圆弧沿顺时针方向起始的角度和结束角度，如果是 $0$ 和 $360$，就是整个椭圆。查看 <code>cv2.ellipse()</code> 可以得到更多信息。下面的例子是在图片的中心绘制半个白色椭圆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cv2.ellipse(img,(<span class="number">256</span>,<span class="number">256</span>),(<span class="number">100</span>,<span class="number">50</span>),<span class="number">0</span>,<span class="number">0</span>,<span class="number">180</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">-1</span>)</span></pre></td></tr></table></figure>
<h3 id="画多边形"><a href="#画多边形" class="headerlink" title="画多边形"></a>画多边形</h3><p>​        画多边形可以使用<code>cv2.polylines()</code>，需要指点每个顶点的坐标。用这些点的坐标构建一个大小等于$行数<em>1</em>2$的数组，行数就是点的数目。这个数组的数据类型必须为 <strong>int32</strong>。 这里画一个黄色的具有四个顶点的多边形。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">pts=np.array([[<span class="number">10</span>,<span class="number">5</span>],[<span class="number">20</span>,<span class="number">30</span>],[<span class="number">70</span>,<span class="number">20</span>],[<span class="number">50</span>,<span class="number">10</span>]], np.int32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">pts=pts.reshape((<span class="number">-1</span>,<span class="number">1</span>,<span class="number">2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">cv2.polylines(img,[pts],<span class="literal">True</span>,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">3</span>)</span></pre></td></tr></table></figure>
<p><strong>注意：</strong> <em>如果第三个参数是 False，我们得到的多边形是不闭合的（首尾不相连）。</em></p>
<p>​            <em><code>cv2.polylines()</code> 可以被用来画很多条线。只需要把想要画的线放在一 个列表中，将这个列表传给函数就可以了。每条线都会被独立绘制。这会比用 <code>cv2.line()</code> 一条一条的绘制要快一些。</em></p>
<h3 id="在图片上添加文字"><a href="#在图片上添加文字" class="headerlink" title="在图片上添加文字"></a>在图片上添加文字</h3><p>要在图片上绘制文字需要设置下列参数：</p>
<ul>
<li>你要绘制的文字</li>
<li>你要绘制的位置</li>
<li>字体类型（通过查看 <code>cv2.putText()</code> 的文档找到支持的字体）</li>
<li>字体的大小</li>
<li>文字的一般属性如颜色，粗细，线条的类型等。为了更好看一点推荐使用 <code>linetype=cv2.LINE_AA</code>。</li>
</ul>
<p>以下代码在图像上绘制<strong>OpenCV</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cv2.putText(img,<span class="string">"OpenCV"</span>,(<span class="number">10</span>,<span class="number">500</span>),font,<span class="number">4</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span></pre></td></tr></table></figure>
<h3 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h3><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/draw.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h2 id="鼠标当画笔"><a href="#鼠标当画笔" class="headerlink" title="鼠标当画笔"></a>鼠标当画笔</h2><p>鼠标事件 :<code>cv2.setMouseCallback()</code></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>events</th>
<th>参数</th>
<th>对应操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv2_EVENT_MOUSEMOVE</code></td>
<td>0</td>
<td>滑动</td>
</tr>
<tr>
<td><code>cv2_EVENT_LBUTTONDOWN</code></td>
<td>1</td>
<td>左键点击</td>
</tr>
<tr>
<td><code>cv2_EVENT_RBUTTONDOWN</code></td>
<td>2</td>
<td>右键点击</td>
</tr>
<tr>
<td><code>cv2_EVENT_MBUTTONDOWN</code></td>
<td>3</td>
<td>中间点击</td>
</tr>
<tr>
<td><code>cv2_EVENT_LBUTTONUP</code></td>
<td>4</td>
<td>左键释放</td>
</tr>
<tr>
<td><code>cv2_EVENT_RBUTTONUP</code></td>
<td>5</td>
<td>右键释放</td>
</tr>
<tr>
<td><code>cv2_EVENT_MBUTTONUP</code></td>
<td>6</td>
<td>中间释放</td>
</tr>
<tr>
<td><code>cv2_EVENT_LBUTTONDBLCLK</code></td>
<td>7</td>
<td>左键双击</td>
</tr>
<tr>
<td><code>cv2_EVENT_RBUTTONDBLCLK</code></td>
<td>8</td>
<td>右键双击</td>
</tr>
<tr>
<td><code>cv2_EVENT_MBUTTONDBLCLK</code></td>
<td>9</td>
<td>中间双击</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>flags</th>
<th>参数</th>
<th>对应操作</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>cv2_EVENT_FLAG_LBUTTON</code></td>
<td>1</td>
<td>左键拖拽</td>
</tr>
<tr>
<td><code>cv2_EVENT_FLAG_RBUTTON</code></td>
<td>2</td>
<td>右键拖拽</td>
</tr>
<tr>
<td><code>cv2_EVENT_FLAG_MBUTTON</code></td>
<td>4</td>
<td>中间拖拽</td>
</tr>
<tr>
<td><code>cv2_EVENT_FLAG_CTRLKEY</code></td>
<td>8</td>
<td>(8~15)按$Ctrl$不放事件</td>
</tr>
<tr>
<td><code>cv2_EVENT_FLAG_SHIFTKEY</code></td>
<td>16</td>
<td>(16~31)按$Shift$不放事件</td>
</tr>
<tr>
<td><code>cv2_EVENT_FLAG_ALTKEY</code></td>
<td>32</td>
<td>(32~39)按$Alt$不放事件</td>
</tr>
</tbody>
</table>
</div>
<p>​        下面代码实现在图片双击左键画一个圆。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#mouse callback function</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event,x,y,flags,param)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> event==cv2.EVENT_LBUTTONDBLCLK:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">cv2.circle(img,(x,y),<span class="number">100</span>,(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>),<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建图像与窗口并将窗口与回调函数绑定</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>,draw_circle)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">'image'</span>,img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> cv2.waitKey(<span class="number">20</span>)&amp;<span class="number">0xFF</span>==<span class="number">27</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<p>​        下面代码完成的任务是根据选择的模式在拖动鼠标时绘制矩形或者是圆圈（就像画图程序中一样）。所以回调函数包含两部分，一部分画矩形，一部分画圆圈。这是一个典型的例子帮助我们更好理解与构建人机交互式程序，比如物体跟踪，图像分割等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当鼠标按下时变为 True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">drawing=<span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 mode 为 true 绘制矩形。按下'm' 变成绘制曲线。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">mode=<span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">ix,iy=<span class="number">-1</span>,<span class="number">-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建回调函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event,x,y,flags,param)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">global</span> ix,iy,drawing,mode</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 当按下左键是返回起始位置坐标</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> event==cv2.EVENT_LBUTTONDOWN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        drawing=<span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        ix,iy=x,y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 当鼠标左键按下并移动是绘制图形。event 可以查看移动，flag 查看是否按下</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">elif</span> event==cv2.EVENT_MOUSEMOVE <span class="keyword">and</span> flags==cv2.EVENT_FLAG_LBUTTON:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> drawing==<span class="literal">True</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> mode==<span class="literal">True</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">                cv2.rectangle(img,(ix,iy),(x,y),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 绘制圆圈，小圆点连在一起就成了线，3 代表了笔画的粗细</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">                cv2.circle(img,(x,y),<span class="number">3</span>,(<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>),<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># 下面注释掉的代码是起始点为圆心，起点到终点为半径的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># r=int(np.sqrt((x-ix)**2+(y-iy)**2))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">            <span class="comment"># cv2.circle(img,(x,y),r,(0,0,255),-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="comment"># 当鼠标松开停止绘画。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">elif</span> event==cv2.EVENT_LBUTTONUP:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">        drawing==<span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># if mode==True:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># cv2.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># else:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># cv2.circle(img,(x,y),5,(0,0,255),-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>,draw_circle)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    cv2.imshow(<span class="string">'image'</span>,img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    k=cv2.waitKey(<span class="number">1</span>)&amp;<span class="number">0xFF</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> k==ord(<span class="string">'m'</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">        mode=<span class="keyword">not</span> mode</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">elif</span> k==<span class="number">27</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">break</span></span></pre></td></tr></table></figure>
<h2 id="滑动条做调色板"><a href="#滑动条做调色板" class="headerlink" title="滑动条做调色板"></a>滑动条做调色板</h2><p>​        现在我们来创建一个简单的程序：通过调节滑动条来设定画板颜色。我们要创建一个窗口来显示显色，还有三个滑动条来设置 B，G，R 的颜色。当滑动滚动条时窗口的颜色也会发生相应改变。默认情况下窗口的起始颜色为黑。</p>
<p>​        <code>cv2.getTrackbarPos()</code> 函数的第一个参数是<strong>滑动条的名字</strong>，第二个参数是<strong>滑动条被放置窗口的名字</strong>，第三个参数是<strong>滑动条的默认位置</strong>。第四个参数是<strong>滑动条的最大值</strong>，第五个参数是<strong>回调函数</strong>，每次滑动条的滑动都会调用回调函数。回调函数通常都会含有一个默认参数，就是滑动条的位置。在本例中这个函数不用做任何事情，我们只需要 pass 就可以了。 滑动条的另外一个重要应用就是<strong>用作转换按钮</strong>。默认情况下 OpenCV 本 身不带有按钮函数。所以我们使用滑动条来代替。在我们的程序中，我们要创建一个转换按钮，只有当装换按钮指向 ON 时，滑动条的滑动才有用，否则窗口都是黑的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">pass</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一副黑色图像</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">img=np.zeros((<span class="number">300</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(<span class="string">'R'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(<span class="string">'G'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(<span class="string">'B'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">switch=<span class="string">'0:OFF\n1:ON'</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(switch,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">1</span>,nothing)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	cv2.imshow(<span class="string">'image'</span>,img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	k=cv2.waitKey(<span class="number">1</span>)&amp;<span class="number">0xFF</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> k==<span class="number">27</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	r=cv2.getTrackbarPos(<span class="string">'R'</span>,<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">	g=cv2.getTrackbarPos(<span class="string">'G'</span>,<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	b=cv2.getTrackbarPos(<span class="string">'B'</span>,<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	s=cv2.getTrackbarPos(switch,<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> s==<span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">		img[:]=<span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">		img[:]=[b,g,r]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<p>​        下面例程实现了创建一个画板，可以自选各种颜色的画笔绘制线条和矩形。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nothing</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">pass</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当鼠标按下时变为 True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">drawing=<span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 如果 mode 为 true 绘制矩形。按下'm' 变成绘制曲线。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">mode=<span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">ix,iy=<span class="number">-1</span>,<span class="number">-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建回调函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">draw_circle</span><span class="params">(event,x,y,flags,param)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	r=cv2.getTrackbarPos(<span class="string">'R'</span>,<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	g=cv2.getTrackbarPos(<span class="string">'G'</span>,<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	b=cv2.getTrackbarPos(<span class="string">'B'</span>,<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	color=(b,g,r)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">global</span> ix,iy,drawing,mode</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当按下左键是返回起始位置坐标</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> event==cv2.EVENT_LBUTTONDOWN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">		drawing=<span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">		ix,iy=x,y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 当鼠标左键按下并移动是绘制图形。event 可以查看移动，flag 查看是否按下</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">elif</span> event==cv2.EVENT_MOUSEMOVE <span class="keyword">and</span> flags==cv2.EVENT_FLAG_LBUTTON:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> drawing==<span class="literal">True</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">if</span> mode==<span class="literal">True</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">				cv2.rectangle(img,(ix,iy),(x,y),color,<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">				<span class="comment"># 绘制圆圈，小圆点连在一起就成了线，3 代表了笔画的粗细</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">				cv2.circle(img,(x,y),<span class="number">3</span>,color,<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">				<span class="comment"># 下面注释掉的代码是起始点为圆心，起点到终点为半径的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">				<span class="comment"># r=int(np.sqrt((x-ix)**2+(y-iy)**2))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">				<span class="comment"># cv2.circle(img,(x,y),r,(0,0,255),-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># 当鼠标松开停止绘画。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">elif</span> event==cv2.EVENT_LBUTTONUP:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">		drawing==<span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># if mode==True:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># cv2.rectangle(img,(ix,iy),(x,y),(0,255,0),-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># else:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># cv2.circle(img,(x,y),5,(0,0,255),-1)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">img=np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">'image'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(<span class="string">'R'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(<span class="string">'G'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(<span class="string">'B'</span>,<span class="string">'image'</span>,<span class="number">0</span>,<span class="number">255</span>,nothing)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">cv2.setMouseCallback(<span class="string">'image'</span>,draw_circle)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">	cv2.imshow(<span class="string">'image'</span>,img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">	k=cv2.waitKey(<span class="number">1</span>)&amp;<span class="number">0xFF</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> k==ord(<span class="string">'m'</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">		mode=<span class="keyword">not</span> mode</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">elif</span> k==<span class="number">27</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">break</span></span></pre></td></tr></table></figure>
<p>​        自己的实现</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">drawing = <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">r,g,b=<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">drawShape</span><span class="params">(event,x,y,flags,parms)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">global</span> drawing,sx,sy,ex,ey,r,g,b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> event == cv2.EVENT_LBUTTONDOWN:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        sx,sy=x,y</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        drawing = <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">elif</span> event == cv2.EVENT_MOUSEMOVE <span class="keyword">and</span> drawing == <span class="literal">True</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        cv2.circle(img,(x,y),<span class="number">3</span>,(b,g,r),<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">elif</span> event == cv2.EVENT_LBUTTONUP:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">        drawing = <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cCR</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">global</span> r,g,b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    r=x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    npclr[:] = [b,g,r]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cCG</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">global</span> r,g,b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    g=x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    npclr[:] = [b, g, r]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cCB</span><span class="params">(x)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">global</span> r,g,b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    b=x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    npclr[:] = [b, g, r]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">img = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">npclr = np.zeros((<span class="number">512</span>,<span class="number">512</span>,<span class="number">3</span>),np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">"image"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">"nc"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(<span class="string">"R"</span>,<span class="string">"nc"</span>,<span class="number">0</span>,<span class="number">255</span>,cCR)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(<span class="string">"G"</span>,<span class="string">"nc"</span>,<span class="number">0</span>,<span class="number">255</span>,cCG)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">cv2.createTrackbar(<span class="string">"B"</span>,<span class="string">"nc"</span>,<span class="number">0</span>,<span class="number">255</span>,cCB)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">cv2.setMouseCallback(<span class="string">"image"</span>,drawShape)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    cv2.imshow(<span class="string">"image"</span>,img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">    cv2.imshow(<span class="string">"nc"</span>,npclr)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(cv2.waitKey(<span class="number">1</span>)&amp;<span class="number">0xFF</span> == <span class="number">27</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<hr>
<h2 id="图像的基础操作"><a href="#图像的基础操作" class="headerlink" title="图像的基础操作"></a>图像的基础操作</h2><h3 id="获取并修改像素值"><a href="#获取并修改像素值" class="headerlink" title="获取并修改像素值"></a>获取并修改像素值</h3><p>​        可以根据像素的行和列的坐标获取他的像素值。对 $BGR$ 图像而言，返回值为 $B，G，R$ 的值。对灰度图像而言，会返回他的灰度值（亮度？intensity）</p>
<h3 id="获取图像属性"><a href="#获取图像属性" class="headerlink" title="获取图像属性"></a>获取图像属性</h3><p>​        图像的属性包括：行，列，通道，图像数据类型，像素数目等</p>
<p>​        <code>img.shape</code> 可以获取图像的形状。他的返回值是一个包含<strong>行数，列数，通道数</strong>的元组。</p>
<p>​        <code>img.size</code>可以返回图像的像素数目</p>
<p>​        <code>img.dtype</code>返回的是图像的数据类型(在OpenCV-Python代码中经常出现数据类型不一致，故在$debug$时要留意)</p>
<h3 id="图像ROI"><a href="#图像ROI" class="headerlink" title="图像ROI"></a>图像ROI</h3><p>​        有时你需要对一幅图像的特定区域进行操作。例如我们要检测一副图像中 眼睛的位置，我们首先应该在图像中找到脸，再在脸的区域中找眼睛，而不是 直接在一幅图像中搜索。这样会提高程序的准确性和性能。</p>
<p>​        $ROI$也是使用 $Numpy$ 索引来获得的。现在我们选择球的部分并把他拷贝到图像的其他区域。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'roi.jpg'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ball=img[<span class="number">280</span>:<span class="number">340</span>,<span class="number">330</span>:<span class="number">390</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">img[<span class="number">273</span>:<span class="number">333</span>,<span class="number">100</span>:<span class="number">160</span>]=ball</span></pre></td></tr></table></figure>
<h3 id="拆分及合并图像通道"><a href="#拆分及合并图像通道" class="headerlink" title="拆分及合并图像通道"></a>拆分及合并图像通道</h3><p>​        有时我们需要对 $BGR$ 三个通道分别进行操作。这是你就需要把 $BGR$ 拆 分成单个通道。有时你需要把独立通道的图片合并成一个 $BGR$ 图像。可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'/home/duan/workspace/opencv/images/roi.jpg'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">b,g,r=cv2.split(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">img=cv2.merge(b,g,r)</span></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'/home/duan/workspace/opencv/images/roi.jpg'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#获取图像蓝色通道</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">b=img[:,:,<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#将图像所有像素红色通道值赋为0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">img[:,:,<span class="number">2</span>]=<span class="number">0</span></span></pre></td></tr></table></figure>
<p><strong>警告：</strong> <em><code>cv2.split()</code> 是一个比较耗时的操作。只有真正需要时才用它，能用 $Numpy$ 索引就尽量用</em></p>
<h3 id="为图像扩边（填充）"><a href="#为图像扩边（填充）" class="headerlink" title="为图像扩边（填充）"></a>为图像扩边（填充）</h3><p>​        如果想在图像周围创建一个边，就像相框一样，你可以使用 <code>cv2.copyMakeBorder()</code> 函数。这经常在卷积运算或 0 填充时被用到。这个函数包括如下参数：</p>
<ul>
<li>$src$ 输入图像 </li>
<li>$top, bottom, left, right$ 对应边界的像素数目。 </li>
<li>$borderType$ 要添加那种类型的边界，类型如下 <ul>
<li><code>cv2.BORDER_CONSTANT</code> 添加有颜色的常数值边界，还需要 下一个参数（$value$）。 </li>
<li><code>cv2.BORDER_REFLECT</code> 边界元素的镜像。比如: $fedcba|abcdefgh|hgfedcb$</li>
<li><code>cv2.BORDER_REFLECT_101</code> or <code>cv2.BORDER_DEFAULT</code> 跟上面一样，但稍作改动。例如: $gfedcb|abcdefgh|gfedcba$ </li>
<li><code>cv2.BORDER_REPLICATE</code> 重复最后一个元素。例如: $aaaaaa| abcdefgh|hhhhhhh$</li>
<li><code>cv2.BORDER_WRAP</code> 不知道怎么说了, 就像这样: $cdefgh| abcdefgh|abcdefg$</li>
</ul>
</li>
<li>$value$ 边界颜色，如果边界的类型是<code>cv2.BORDER_CONSTANT</code></li>
</ul>
<p>演示程序</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">BLUE=[<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">img1=cv2.imread(<span class="string">'opencv_logo.png'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">replicate = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REPLICATE)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">reflect = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REFLECT)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">reflect101 = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_REFLECT_101)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">wrap = cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_WRAP)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">constant= cv2.copyMakeBorder(img1,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,<span class="number">10</span>,cv2.BORDER_CONSTANT,value=BLUE)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">231</span>),plt.imshow(img1,<span class="string">'gray'</span>),plt.title(<span class="string">'ORIGINAL'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">232</span>),plt.imshow(replicate,<span class="string">'gray'</span>),plt.title(<span class="string">'REPLICATE'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">233</span>),plt.imshow(reflect,<span class="string">'gray'</span>),plt.title(<span class="string">'REFLECT'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">234</span>),plt.imshow(reflect101,<span class="string">'gray'</span>),plt.title(<span class="string">'REFLECT_101'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">235</span>),plt.imshow(wrap,<span class="string">'gray'</span>),plt.title(<span class="string">'WRAP'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">236</span>),plt.imshow(constant,<span class="string">'gray'</span>),plt.title(<span class="string">'CONSTANT'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<h3 id="图像上的-算术运算"><a href="#图像上的-算术运算" class="headerlink" title="图像上的 算术运算"></a>图像上的 算术运算</h3><h4 id="图像加法"><a href="#图像加法" class="headerlink" title="图像加法"></a>图像加法</h4><p>​        可以使用函数 <code>cv2.add()</code> 将两幅图像进行加法运算，当然也可以直接使 用 $numpy$，$res=img1+img$。两幅图像的<strong>大小，类型</strong>必须一致，或者第二个 图像可以使一个简单的标量值。</p>
<p><strong>注意：</strong> <em>$OpenCV$中的加法与 $Numpy$ 的加法是有所不同的。$OpenCV$ 的加法 是一种饱和操作，而 $Numpy$ 的加法是一种模操作。</em></p>
<p>​    例如下面的两个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">x = np.uint8([<span class="number">250</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">y = np.uint8([<span class="number">10</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> cv2.add(x,y) <span class="comment"># 250+10 = 260 =&gt; 255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> x+y <span class="comment"># 250+10 = 260 % 256 = 4</span></span></pre></td></tr></table></figure>
<p>​    这种差别在你对两幅图像进行加法时会更加明显。OpenCV 的结果会更好 一点。所以我们尽量使用 OpenCV 中的函数。</p>
<h4 id="图像混合"><a href="#图像混合" class="headerlink" title="图像混合"></a>图像混合</h4><p>​        这其实也是加法，但是不同的是两幅图像的权重不同，这就会给人一种混 合或者透明的感觉。图像混合的计算公式如下： ​</p>
<script type="math/tex; mode=display">
g (x) = (1 − α) f_0 (x) + αf_1 (x)</script><p>​        通过修改 α 的值（0 → 1），可以实现非常酷的混合。 </p>
<p>​        现在我们把两幅图混合在一起。第一幅图的权重是 0.7，第二幅图的权重 是 0.3。函数 <code>cv2.addWeighted()</code> 可以按下面的公式对图片进行混合操作。</p>
<script type="math/tex; mode=display">
dst = α · img_1 + β · img_2 + γ</script><p>​        这里$\gamma$取值为0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"material/1.png"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img2 = cv2.imread(<span class="string">"material/3.png"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">dst = cv2.addWeighted(img,<span class="number">0.7</span>,img2,<span class="number">0.3</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"dst"</span>,dst)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<h4 id="按位运算"><a href="#按位运算" class="headerlink" title="按位运算"></a>按位运算</h4><p>​        这里包括的按位操作有：$AND，OR，NOT，XOR$ 等。当我们提取图像的 一部分，选择非矩形 $ROI$ 时这些操作会很有用（下一章就会明白）。下面的例子就是教我们如何改变一幅图的特定区域。 如果想把 $OpenCV$ 的标志放到另一幅图像上。如果使用加法，颜色会改 变，如果使用混合，会得到透明效果，但是我不想要透明。如果他是矩形我可以像上一章那样使用 ROI。但是他不是矩形。但是我们可以通过下面的按位运算实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加载图像</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">'roi.jpg'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">img2 = cv2.imread(<span class="string">'opencv_logo.png'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># I want to put logo on top-left corner, So I create a ROI</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">rows,cols,channels = img2.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">roi = img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols ]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Now create a mask of logo and create its inverse mask also</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">img2gray = cv2.cvtColor(img2,cv2.COLOR_BGR2GRAY)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">ret, mask = cv2.threshold(img2gray, <span class="number">175</span>, <span class="number">255</span>, cv2.THRESH_BINARY)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">mask_inv = cv2.bitwise_not(mask)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Now black-out the area of logo in ROI</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取 roi 中与 mask 中不为零的值对应的像素的值，其他值为 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 注意这里必须有 mask=mask 或者 mask=mask_inv, 其中的 mask= 不能忽略</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">img1_bg = cv2.bitwise_and(roi,roi,mask = mask)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 取 roi 中与 mask_inv 中不为零的值对应的像素的值，其他值为 0。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Take only region of logo from logo image.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">img2_fg = cv2.bitwise_and(img2,img2,mask = mask_inv)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Put logo in ROI and modify the main image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">dst = cv2.add(img1_bg,img2_fg)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">img1[<span class="number">0</span>:rows, <span class="number">0</span>:cols ] = dst</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">'res'</span>,img1)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<p>​        实现两张图片平滑过渡</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">"material/18.png"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img2 = cv2.imread(<span class="string">"material/20.png"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0.01</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    cv2.imshow(<span class="string">"image"</span>,cv2.addWeighted(img1,<span class="number">1</span>-i,img2,i,<span class="number">0</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    cv2.waitKey(<span class="number">40</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<h3 id="程序性能检测及优化"><a href="#程序性能检测及优化" class="headerlink" title="程序性能检测及优化"></a>程序性能检测及优化</h3><h4 id="使用-OpenCV-检测程序效率"><a href="#使用-OpenCV-检测程序效率" class="headerlink" title="使用 OpenCV 检测程序效率"></a>使用 OpenCV 检测程序效率</h4><p>​        <code>cv2.getTickCount</code> 函数返回从参考点到这个函数被执行的时钟数。所 以当你在一个函数执行前后都调用它的话，你就会得到这个函数的执行时间 （时钟数）。</p>
<p>​        <code>cv2.getTickFrequency</code> 返回时钟频率，或者说每秒钟的时钟数。所以 你可以按照下面的方式得到一个函数运行了多少秒：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">e1 = cv2.getTickCount()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># your code execution</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">e2 = cv2.getTickCount()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">time = (e2 - e1)/ cv2.getTickFrequency()</span></pre></td></tr></table></figure>
<p><strong>注 意：</strong>  <em>你 也 可 以 中 time 模 块 实 现 上 面 的 功 能。 但 是 要 用 的 函 数 是 <code>time.time()</code> 而不是 <code>cv2.getTickCount()</code>。比较一下这两个结果的差别吧。</em></p>
<h4 id="OpenCV的默认优化"><a href="#OpenCV的默认优化" class="headerlink" title="OpenCV的默认优化"></a>OpenCV的默认优化</h4><p>​        OpenCV 中的很多函数都被优化过（使用 $SSE2$，$AVX$ 等）。也包含一些没有被优化的代码。如果我们的系统支持优化的话要尽量利用这一点。在编译时优化是被默认开启的。因此 OpenCV 运行的就是优化后的代码，如果你把优化关闭的话就只能执行低效的代码了。可以使用函数 <code>cv2.useOptimized()</code> 来查看优化是否被开启了，使用函数 <code>cv2.setUseOptimized()</code> 来开启优化。 </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># check if optimization is enabled</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: cv2.useOptimized()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">Out[<span class="number">5</span>]: <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">6</span>]: %timeit res = cv2.medianBlur(img,<span class="number">49</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">34.9</span> ms per loop</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Disable it</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">7</span>]: cv2.setUseOptimized(<span class="literal">False</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: cv2.useOptimized()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">Out[<span class="number">8</span>]: <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">9</span>]: %timeit res = cv2.medianBlur(img,<span class="number">49</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">64.1</span> ms per loop</span></pre></td></tr></table></figure>
<p>​        优化后中值滤波的速度是原来的两倍。如果查看源代码的话会发现中值滤波是被 SIMD 优化的。所以可以在代码的开始处开启优化 （记住优化是默认开启的）。</p>
<h4 id="在-IPython-中检测程序效率"><a href="#在-IPython-中检测程序效率" class="headerlink" title="在 $IPython$ 中检测程序效率"></a>在 $IPython$ 中检测程序效率</h4><p>​        有时你需要比较两个相似操作的效率，这时你可以使用 $IPython$ 为你提供的魔法命令<code>%time</code>。他会让代码运行好几次从而得到一个准确的（运行）时间。它也可以被用来测试单行代码的效率。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">2</span>]: <span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">3</span>]: x = <span class="number">5</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">4</span>]: %timeit y=x**<span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="number">270</span> ns ± <span class="number">16.2</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000000</span> loops each)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">5</span>]: %timeit y=x*x</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="number">41.5</span> ns ± <span class="number">3.73</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">10000000</span> loops each)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">6</span>]: z = np.uint8([<span class="number">5</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">7</span>]: %timeit y=z*z</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="number">422</span> ns ± <span class="number">7.82</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000000</span> loops each)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">8</span>]: %timeit y=np.square(z)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="number">430</span> ns ± <span class="number">26.7</span> ns per loop (mean ± std. dev. of <span class="number">7</span> runs, <span class="number">1000000</span> loops each)</span></pre></td></tr></table></figure>
<p><strong>注意：</strong> <em>$Python$ 的标量计算比 $Numpy$ 的标量计算要快。对于仅包含一两个 元素的操作 $Python$ 标量比 $Numpy$ 的数组要快。但是当数组稍微大一点时 $Numpy$ 就会胜出了。</em></p>
<p>​        下面比较一下 <code>cv2.countNonZero()</code> 和 <code>np.count_nonzero()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">35</span>]: %timeit z = cv2.countNonZero(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="number">100000</span> loops, best of <span class="number">3</span>: <span class="number">15.8</span> us per loop</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">In [<span class="number">36</span>]: %timeit z = np.count_nonzero(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="number">1000</span> loops, best of <span class="number">3</span>: <span class="number">370</span> us per loop</span></pre></td></tr></table></figure>
<p>注意：一般情况下 $OpenCV$ 的函数要比 $Numpy$ 函数快。所以对于相同的操作最好使用 $OpenCV$ 的函数。当然也有例外，尤其是当使用 $Numpy$ 对视图 （而非复制）进行操作时。</p>
<h4 id="更多-IPython-的魔法命令"><a href="#更多-IPython-的魔法命令" class="headerlink" title="更多 $IPython$ 的魔法命令"></a>更多 $IPython$ 的魔法命令</h4><p>​        还有几个魔法命令可以用来检测程序的效率，$profiling$，$line profiling$， 内存使用等。他们都有完善的文档，感兴趣的可以自己学习一下。</p>
<h4 id="效率优化技术"><a href="#效率优化技术" class="headerlink" title="效率优化技术"></a>效率优化技术</h4><p>​        有些技术和编程方法可以让我们最大的发挥 $Python$ 和 $Numpy$ 的威力。 我们这里仅仅提一下相关的，你可以通过超链接查找更多详细信息。最重要的一点是：首先用简单的方式实现你的算法（结果正确最重要），当结果正确后，再使用上面的提到的方法找到程序的瓶颈来优化它。</p>
<ol>
<li>尽量避免使用循环，尤其双层三层循环，它们天生就是非常慢的。 </li>
<li>算法中尽量使用向量操作，因为 $Numpy$ 和 $OpenCV$ 都对向量操作进行 了优化。</li>
<li>利用高速缓存一致性。</li>
<li>没有必要的话就不要复制数组。使用视图来代替复制。数组复制是非常浪费资源的。 </li>
</ol>
<p>​        就算进行了上述优化，如果你的程序还是很慢，或者说大的训话不可避免的话， 应该尝试使用其他的包，比如说 $Cython$，来加速程序。</p>
<h3 id="OpenCV-中的数学工具"><a href="#OpenCV-中的数学工具" class="headerlink" title="OpenCV 中的数学工具"></a>OpenCV 中的数学工具</h3><p>缺失</p>
<h2 id="OpenCV-中的图像处理"><a href="#OpenCV-中的图像处理" class="headerlink" title="OpenCV 中的图像处理"></a>OpenCV 中的图像处理</h2><h3 id="颜色空间转换"><a href="#颜色空间转换" class="headerlink" title="颜色空间转换"></a>颜色空间转换</h3><h4 id="转换颜色空间"><a href="#转换颜色空间" class="headerlink" title="转换颜色空间"></a>转换颜色空间</h4><p>​        在 OpenCV 中有超过 150 中进行颜色空间转换的方法。但是你以后就会 发现我们经常用到的也就两种：$BGR↔Gray$ 和 $BGR↔HSV$。 </p>
<p>​        我们要用到的函数是：<code>cv2.cvtColor(input_image，flag)</code>，其中 $flag$ 就是转换类型。 </p>
<p>​        对于 $BGR↔Gray$ 的转换，我们要使用的 $flag$ 就是 <code>cv2.COLOR_BGR2GRAY</code>。同样对于 $BGR↔HSV$ 的转换，我们用的 $flag$ 就是 <code>cv2.COLOR_BGR2HSV</code>。 可以通过下面的命令得到所有可用的 $flag$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">flags=[i <span class="keyword">for</span> <span class="keyword">in</span> dir(cv2) <span class="keyword">if</span> i startswith(<span class="string">'COLOR_'</span>)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> flags</span></pre></td></tr></table></figure>
<p><strong>注意：</strong> <em>在 $OpenCV$ 的 $HSV$ 格式中，$H$（色彩/色度）的取值范围是 $[0，179]$， $S$（饱和度）的取值范围 $[0，255]$，$V$（亮度）的取值范围 $[0，255]$。但是不同的软件使用的值可能不同。所以当你需要拿 $OpenCV$ 的 $HSV$ 值与其他软件的 $HSV$ 值进行对比时，一定要记得<strong>归一化</strong>。</em></p>
<h4 id="物体跟踪"><a href="#物体跟踪" class="headerlink" title="物体跟踪"></a>物体跟踪</h4><p>​        知道怎样将一幅图像从 $BGR$ 转换到 $HSV$ 了，我们可以利用这一点来提取带有某个特定颜色的物体。在 $HSV$ 颜色空间中要比在 $BGR$ 空间 中更容易表示一个特定颜色。在我们的程序中，我们要提取的是一个蓝色的物体。下面就是就是我们要做的几步：</p>
<ul>
<li>从视频中获取每一帧图像</li>
<li>将图像转换到 HSV 空间</li>
<li>设置 HSV 阈值到蓝色范围。</li>
<li>获取蓝色物体，当然我们还可以做其他任何我们想做的事，比如：在蓝色物体周围画一个圈。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">cap=cv2.VideoCapture(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取每一帧</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">ret,frame=cap.read()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转换到 HSV</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">hsv=cv2.cvtColor(frame,cv2.COLOR_BGR2HSV)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定蓝色的阈值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">lower_blue=np.array([<span class="number">110</span>,<span class="number">50</span>,<span class="number">50</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">upper_blue=np.array([<span class="number">130</span>,<span class="number">255</span>,<span class="number">255</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据阈值构建掩模</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">mask=cv2.inRange(hsv,lower_blue,upper_blue)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对原图像和掩模进行位运算</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">res=cv2.bitwise_and(frame,frame,mask=mask)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示图像</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">'frame'</span>,frame)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">'mask'</span>,mask)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">'res'</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">k=cv2.waitKey(<span class="number">5</span>)&amp;<span class="number">0xFF</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> k==<span class="number">27</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关闭窗口</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<p><strong>注意：</strong> <em>这是物体跟踪中最简单的方法。当你学习了轮廓之后，你就会学到更多相关知识，那是你就可以找到物体的重心，并根据重心来跟踪物体，仅仅在摄像头前挥挥手就可以画出同的图形，或者其他更有趣的事。</em></p>
<h4 id="找到要跟踪对象的-HSV-值"><a href="#找到要跟踪对象的-HSV-值" class="headerlink" title="找到要跟踪对象的 $HSV$ 值"></a>找到要跟踪对象的 $HSV$ 值</h4><p>​        函数 <code>cv2.cvtColor()</code> 也可以用到这里。但是现在你要传入的参数是（你想要的）$BGR$ 值而不是一副图。例如，我们要找到绿色的 $HSV$ 值，我们只需在终端输入以下命令：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">green=np.uint8([<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">hsv_green=cv2.cvtColor(green,cv2.COLOR_BGR2HSV)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> hsv_green</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># [[[60 255 255]]]</span></span></pre></td></tr></table></figure>
<p>​        现在你可以分别用 [H-100，100，100] 和 [H+100，255，255] 做上下阈值。除了这个方法之外，你可以使用任何其他图像编辑软件（例如 GIMP） 或者在线转换软件找到相应的 $HSV$ 值，但是最后别忘了调节 $HSV$ 的范围。</p>
<h3 id="几何变换"><a href="#几何变换" class="headerlink" title="几何变换"></a>几何变换</h3><p>​        OpenCV 提供了两个变换函数，<code>cv2.warpAffine</code> 和 <code>cv2.warpPerspective</code>， 使用这两个函数你可以实现所有类型的变换。<code>cv2.warpAffine</code> 接收的参数是 $2 × 3$ 的变换矩阵，而 <code>cv2.warpPerspective</code> 接收的参数是 $3 × 3$ 的变换矩阵。</p>
<h4 id="扩展缩放"><a href="#扩展缩放" class="headerlink" title="扩展缩放"></a>扩展缩放</h4><p>​        扩展缩放只是改变图像的尺寸大小。OpenCV 提供的函数 <code>cv2.resize()</code> 可以实现这个功能。图像的尺寸可以自己手动设置，你也可以指定缩放因子。我们可以选择使用不同的插值方法。在缩放时我们推荐使用 <code>cv2.INTER_AREA</code>， 在扩展时我们推荐使用 <code>cv2.INTER_CUBIC</code>（慢) 和 <code>v2.INTER_LINEAR</code>。 默认情况下所有改变图像尺寸大小的操作使用的插值方法都是 <code>cv2.INTER_LINEAR</code>。 你可以使用下面任意一种方法改变图像的尺寸：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'messi5.jpg'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#Resize(src, dst, interpolation=CV_INTER_LINEAR)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面的 None 本应该是输出图像的尺寸，但是因为后边我们设置了缩放因子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 因此这里为 None</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">res=cv2.resize(img,<span class="literal">None</span>,fx=<span class="number">2</span>,fy=<span class="number">2</span>,interpolation=cv2.INTER_CUBIC)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#OR</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里呢，我们直接设置输出图像的尺寸，所以不用设置缩放因子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">height,width=img.shape[:<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">res=cv2.resize(img,(<span class="number">2</span>*width,<span class="number">2</span>*height),interpolation=cv2.INTER_CUBIC)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	cv2.imshow(<span class="string">'res'</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	cv2.imshow(<span class="string">'img'</span>,img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> cv2.waitKey(<span class="number">1</span>) &amp; <span class="number">0xFF</span> == <span class="number">27</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">break</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<h4 id="平移"><a href="#平移" class="headerlink" title="平移"></a>平移</h4><p>​        平移就是将对象换一个位置。如果你要沿$(x,y)$方向移动，移动的距离 是$(tx,ty)$，你可以以下面的方式构建移动矩阵：</p>
<script type="math/tex; mode=display">
M = \begin{bmatrix}1 & 0 & t_x \\ 
0 & 1 & t_y\end{bmatrix}</script><p>​        你可以使用 $Numpy$ 构建这个矩阵（数据类型是 $np.float32$），然后把它传给函数 <code>cv2.warpAffine()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cv2.warpAffine(src, M, dsize[, dst[, flags[, borderMode[, borderValue]]]]) → dst</span></pre></td></tr></table></figure>
<p>其中：</p>
<p>$src$ – 输入图像。<br>$M$ – 变换矩阵。<br>$dsize$ – 输出图像的大小。<br>$flags$ – 插值方法的组合（int 类型！）<br>$borderMode$ – 边界像素模式（int 类型！）<br>$borderValue$ – （重点！）边界填充值; 默认情况下，它为0。</p>
<p>上述参数中：</p>
<p>$M$作为仿射变换矩阵，一般反映平移或旋转的关系，为$InputArray$类型的$2×3$的变换矩阵。</p>
<p>$flags$表示插值方式，默认为 <code>flags=cv2.INTER_LINEAR</code>，表示线性插值，</p>
<p>此外还有：</p>
<p><code>cv2.INTER_NEAREST​</code>（最近邻插值）</p>
<p><code>cv2.INTER_AREA​</code> （区域插值）</p>
<p><code>cv2.INTER_CUBIC​</code>（三次样条插值）</p>
<p><code>cv2.INTER_LANCZOS4</code>（$Lanczos$插值）</p>
<p>日常进行仿射变换时，在只设置前三个参数的情况下，如 <code>cv2.warpAffine(img,M,(rows,cols))</code>可以实现基本的仿射变换效果，但因为边界填充值为$(0,0,0)$ ,可能会出现“黑边”现象。要使周围填充白色，可以：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cv2.warpAffine(img,M,(lengh,lengh),borderValue=(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span></pre></td></tr></table></figure>
<p><strong>警告：</strong> <em>函数 <code>cv2.warpAffine()</code> 的第三个参数的是输出图像的大小，它的格式应该是图像的（宽，高）。应该记住的是图像的宽对应的是列数，高对应的是行数。</em></p>
<p>​    下面的代码将图像按$(100，50)$ 平移</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">"image"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"material/0.png"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">M = np.float32([[<span class="number">1</span>,<span class="number">0</span>,<span class="number">100</span>],[<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">res = cv2.warpAffine(img,M,img.shape[:<span class="number">2</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"image"</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/trans.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="旋转"><a href="#旋转" class="headerlink" title="旋转"></a>旋转</h4><p>​        对一个图像旋转角度 $θ$, 需要使用到下面形式的旋转矩阵。</p>
<script type="math/tex; mode=display">
M=\begin{bmatrix} \cos \theta & -\sin \theta \\ 
\sin \theta & \cos \theta \end{bmatrix}</script><p>​        但是 OpenCV 允许绕任意地方进行旋转，但是旋转矩阵的形式应该修改为</p>
<script type="math/tex; mode=display">
\begin{bmatrix} \alpha & \beta & (1-\alpha)\cdot center.x - \beta \cdot center.y \\ 
-\beta & \alpha & \beta \cdot center.x + (1-\alpha) \cdot center.y \end{bmatrix}</script><p>​        其中：</p>
<script type="math/tex; mode=display">
\alpha = scale \cdot \cos \theta \\
\beta = scale \cdot \sin \theta</script><p>为了构建这个旋转矩阵，$OpenCV$ 提供了一个函数：<code>cv2.getRotationMatrix2D</code>。 下面的例子是在不缩放的情况下将图像旋转 $90$ 度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">"image"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"material/0.png"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">width,height = img.shape[:<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里的第一个参数为旋转中心，第二个为旋转角度，第三个为旋转后的缩放因子</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 可以通过设置旋转中心，缩放因子，以及窗口大小来防止旋转后超出边界的问题</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">M = cv2.getRotationMatrix2D((width//<span class="number">2</span>,height//<span class="number">2</span>),<span class="number">45</span>,<span class="number">0.6</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第三个参数是输出图像的尺寸中心</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">res = cv2.warpAffine(img,M,(<span class="number">600</span>,<span class="number">600</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 旋转之后图像外的部分消失</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># M2 = np.float32([[1,0,100],[0,1,50]])</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># res = cv2.warpAffine(res,M2,(600,600))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"image"</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"ratation.png"</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/rotation.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h4><p>​        在仿射变换中，原图中所有的平行线在结果图像中同样平行。为了创建这 个矩阵我们需要从原图像中找到三个点以及他们在输出图像中的位置。然后 <code>cv2.getAffineTransform</code> 会创建一个 $2*3$ 的矩阵，最后这个矩阵会被传给函数 <code>cv2.warpAffine</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'material/0.png'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">rows,cols,ch=img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">pts1=np.float32([[<span class="number">50</span>,<span class="number">50</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">50</span>,<span class="number">200</span>]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">pts2=np.float32([[<span class="number">10</span>,<span class="number">100</span>],[<span class="number">200</span>,<span class="number">50</span>],[<span class="number">100</span>,<span class="number">250</span>]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">M=cv2.getAffineTransform(pts1,pts2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">res=cv2.warpAffine(img,M,(cols,rows))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"image"</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"affine.png"</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/affine.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="透视变换"><a href="#透视变换" class="headerlink" title="透视变换"></a>透视变换</h4><p>对于视角变换，我们需要一个 $3*3$ 变换矩阵。在变换前后直线还是直线。 要构建这个变换矩阵，你需要在输入图像上找 $4$ 个点，以及他们在输出图像上对应的位置。这四个点中的任意三个都不能共线。这个变换矩阵可以有函数 <code>cv2.getPerspectiveTransform()</code> 构建。然后把这个矩阵传给函数 <code>cv2.warpPerspective</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'material/0.png'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">img = cv2.resize(img,(<span class="number">300</span>,<span class="number">300</span>),cv2.INTER_AREA)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">rows,cols,ch=img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">print(img.shape)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">pts1 = np.float32([[<span class="number">56</span>,<span class="number">65</span>],[<span class="number">368</span>,<span class="number">52</span>],[<span class="number">28</span>,<span class="number">387</span>],[<span class="number">389</span>,<span class="number">390</span>]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">pts2 = np.float32([[<span class="number">0</span>,<span class="number">0</span>],[<span class="number">300</span>,<span class="number">0</span>],[<span class="number">0</span>,<span class="number">300</span>],[<span class="number">300</span>,<span class="number">300</span>]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">M=cv2.getPerspectiveTransform(pts1,pts2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">dst=cv2.warpPerspective(img,M,(<span class="number">300</span>,<span class="number">300</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"image"</span>,dst)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<h3 id="图像阈值"><a href="#图像阈值" class="headerlink" title="图像阈值"></a>图像阈值</h3><h4 id="简单阈值"><a href="#简单阈值" class="headerlink" title="简单阈值"></a>简单阈值</h4><p>​        与名字一样，这种方法非常简单。但像素值高于阈值时，我们给这个像素赋予一个新值（可能是白色），否则我们给它赋予另外一种颜色（也许是黑色）。 这个函数就是 <code>cv2.threshhold()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cv2.threshold (src, thresh, maxval, type)</span></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>src</td>
<td>源图片，必须是单通道</td>
</tr>
<tr>
<td>thresh</td>
<td>阈值，取值范围0～255</td>
</tr>
<tr>
<td>maxval</td>
<td>填充色，取值范围0～255</td>
</tr>
<tr>
<td>type</td>
<td>阈值类型，见下表</td>
</tr>
</tbody>
</table>
</div>
<p>这个函数的第一个参数就是<strong>原图像</strong>，原图像应该是<strong>灰度图</strong>。第二个参数就是<strong>用来对像素值进行分类的阈值</strong>。第三个参数就是<strong>当像素值高于（有时是小于）阈值时应该被赋予的新的像素值</strong>。OpenCV 提供了多种不同的阈值方法，这是由<strong>第四个参数来决定</strong>的。这些方法包括：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>type</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>$cv2.THRESH_BINARY$</td>
<td>二进制阈值化，非黑即白</td>
</tr>
<tr>
<td>$cv2.THRESH_BINARY_INV$</td>
<td>反二进制阈值化，非白即黑</td>
</tr>
<tr>
<td>$cv2.THRESH_TRUNC$</td>
<td>截断阈值化 ，大于阈值设为阈值</td>
</tr>
<tr>
<td>$cv2.THRESH_TOZERO$</td>
<td>阈值化为0 ，小于阈值设为0</td>
</tr>
<tr>
<td>$cv2.THRESH_TOZERO_INV$</td>
<td>反阈值化为0 ，大于阈值设为0</td>
</tr>
</tbody>
</table>
</div>
<p>​        这个函数有两个返回值，第一个为 $retVal$，我们后面会解释。第二个就是 阈值化之后的结果图像了。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'material/11.png'</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">ret,thresh1=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">ret,thresh2=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">ret,thresh3=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TRUNC)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ret,thresh4=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">ret,thresh5=cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_TOZERO_INV)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">titles = [<span class="string">'Original Image'</span>,<span class="string">'BINARY'</span>,<span class="string">'BINARY_INV'</span>,<span class="string">'TRUNC'</span>,<span class="string">'TOZERO'</span>,<span class="string">'TOZERO_INV'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">3</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    plt.title(titles[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    plt.xticks([]),plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/simthresh.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="自适应阈值"><a href="#自适应阈值" class="headerlink" title="自适应阈值"></a>自适应阈值</h4><p>​        在前面的部分我们使用是全局阈值，整幅图像采用同一个数作为阈值。但是这种方法并不适应于所有情况，尤其是当同一幅图像上的不同部分的具有不同亮度时。这种情况下我们需要采用自适应阈值<code>cv2.adaptiveThreshold()</code>。此时的阈值是<strong>根据图像上的每一个小区域计算与其对应的阈值</strong>。因此在同一幅图像上的不同区域采用的是不同的阈值，从而使我们能在亮度不同的情况下得到更好的结果。 </p>
<p>这种方法需要我们指定三个参数，返回值只有一个。</p>
<ul>
<li><p>$Adaptive Method$- 指定计算阈值的方法。 </p>
<ul>
<li><code>cv2.ADPTIVE_THRESH_MEAN_C</code>：阈值取自相邻区域的平均值 </li>
<li><code>cv2.ADPTIVE_THRESH_GAUSSIAN_C</code>：阈值取值相邻区域的加权和，权重为一个高斯窗口。</li>
</ul>
</li>
<li><p>$Block Size$ - 邻域大小（用来计算阈值的区域大小）。</p>
</li>
<li><p>$C$ - 这就是是一个常数，阈值就等于平均值或者加权平均值减去这个常数。</p>
<p> 我们使用下面的代码来展示简单阈值与自适应阈值的差别：</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"material/1.jpg"</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 中值滤波</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">img = cv2.medianBlur(img,<span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">ret, th1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#11 为 Block size, 2 为 C 值</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">th2 = cv2.adaptiveThreshold(img,<span class="number">255</span>,cv2.ADAPTIVE_THRESH_MEAN_C,cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">th3 = cv2.adaptiveThreshold(img,<span class="number">255</span>,cv2.ADAPTIVE_THRESH_GAUSSIAN_C,cv2.THRESH_BINARY,<span class="number">11</span>,<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">th2 = cv2.medianBlur(th2,<span class="number">7</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">th3 = cv2.medianBlur(th3,<span class="number">7</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">titles = [<span class="string">'Original Image'</span>, <span class="string">'Global Thresholding (v = 127)'</span>,<span class="string">'Adaptive Mean Thresholding'</span>, <span class="string">'Adaptive Gaussian Thresholding'</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">images = [img, th1,th2,th3]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,i+<span class="number">1</span>),plt.imshow(images[i],<span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    plt.title(titles[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    plt.xticks([]),plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/adtthresh.png" alt="图待补" title="">
                </div>
                <div class="image-caption">图待补</div>
            </figure>
<h4 id="Otsu’s-二值化"><a href="#Otsu’s-二值化" class="headerlink" title="$Otsu’s$ 二值化"></a>$Otsu’s$ 二值化</h4><p>​        在第一部分中我们提到过 $retVal$，当我们使用 <strong>$Otsu$ 二值化</strong>时会用到它。</p>
<p>​        在使用全局阈值时，我们就是随便给了一个数来做阈值，那我们怎么知道这个数的好坏呢？答案就是不停的尝试。如果是一副双峰图像（简单来说双峰图像是指图像直方图中存在两个峰）呢？我们岂不是应该在两个峰之间的峰谷选一个值作为阈值？这就是 $Otsu$ 二值化要做的。简单来说就是对一副双峰图像自动根据其直方图计算出一个阈值。（对于非双峰图像，这种方法得到的结果可能会不理想）。 这里用到的函数还是 <code>cv2.threshold()</code>，但是需要多传入一个参数 （flag）：<code>cv2.THRESH_OTSU</code>。这时要把阈值设为 0。然后算法会找到最优阈值，这个最优阈值就是返回值 $retVal$。如果不使用 $Otsu$ 二值化，返回的 $retVal$ 值与设定的阈值相等。</p>
<p>例程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'noisy2.png'</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># global thresholding</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">ret1,th1 = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Otsu's thresholding</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">ret2,th2 = cv2.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Otsu's thresholding after Gaussian filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#（5,5）为高斯核的大小，0 为标准差</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">blur = cv2.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 阈值一定要设为 0！</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">ret3,th3 = cv2.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># plot all the images and their histograms</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">images = [img, <span class="number">0</span>, th1,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">		  img, <span class="number">0</span>, th2,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">		  blur, <span class="number">0</span>, th3]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">titles = [<span class="string">'Original Noisy Image'</span>,<span class="string">'Histogram'</span>,<span class="string">'Global Thresholding (v=127)'</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">		  <span class="string">'Original Noisy Image'</span>,<span class="string">'Histogram'</span>,<span class="string">"Otsu's Thresholding"</span>,</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">		  <span class="string">'Gaussian filtered Image'</span>,<span class="string">'Histogram'</span>,<span class="string">"Otsu's Thresholding"</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里使用了 pyplot 中画直方图的方法，plt.hist, 要注意的是它的参数是一维数组</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所以这里使用了（numpy）ravel 方法，将多维数组转换成一维，也可以使用 flatten 方法</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#ndarray.flat 1-D iterator over an array.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#ndarray.flatten 1-D array copy of the elements of an array in row-major order.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">	plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">1</span>),plt.imshow(images[i*<span class="number">3</span>],<span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">	plt.title(titles[i*<span class="number">3</span>]), plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">	plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">2</span>),plt.hist(images[i*<span class="number">3</span>].ravel(),<span class="number">256</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">	plt.title(titles[i*<span class="number">3</span>+<span class="number">1</span>]), plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">	plt.subplot(<span class="number">3</span>,<span class="number">3</span>,i*<span class="number">3</span>+<span class="number">3</span>),plt.imshow(images[i*<span class="number">3</span>+<span class="number">2</span>],<span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">	plt.title(titles[i*<span class="number">3</span>+<span class="number">2</span>]), plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<h4 id="otsu-工作原理"><a href="#otsu-工作原理" class="headerlink" title="$otsu$工作原理"></a>$otsu$工作原理</h4><pre><code>对于图像 I(x,y)，前景(即目标)和背景的分割阈值记作 T，属于前景的像素点数占整幅图像的比例记为 ω0，平均灰度为 μ0；背景像素点数占整幅图像的比例为 ω1，平均灰度为 μ1；整幅图像的平均灰度记为μ，类间方差记为g。
</code></pre><p>假设图像大小为$M×N$，图像中像素的灰度值小于阈值$T$的像素个数为 $N_0$，像素灰度大于阈值$T$的像素个数为 $N_1$，那么：</p>
<script type="math/tex; mode=display">
\begin{align*}
&ω_0=N_0/M×N\\
&ω_1=N_1/M×N\\
&N_0+N_1=M×N\\
&ω_0+ω_1=1\\
&μ=ω_0*μ_0+ω_1*μ_1\\
&g=ω_0(μ_0-μ)^2+ω_1(μ_1-μ)^2\\
&g=ω_0ω_1(μ_0-μ_1)^2\\
\end{align*}</script><p>采用遍历的方法使得类间方差$g$最大的阈值$T$，即为所求。$Ostu$方法可以形象地理解为：求取直方图有两个峰值的图像中那两个峰值之间的低谷值$T$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'noisy2.png'</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">blur = cv2.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># find normalized_histogram, and its cumulative distribution function</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算归一化直方图</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#CalcHist(image, accumulate=0, mask=NULL)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">hist = cv2.calcHist([blur],[<span class="number">0</span>],<span class="literal">None</span>,[<span class="number">256</span>],[<span class="number">0</span>,<span class="number">256</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">hist_norm = hist.ravel()/hist.max()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">Q = hist_norm.cumsum()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">bins = np.arange(<span class="number">256</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">fn_min = np.inf</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">thresh = <span class="number">-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">256</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	p1,p2 = np.hsplit(hist_norm,[i]) <span class="comment"># probabilities</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">	q1,q2 = Q[i],Q[<span class="number">255</span>]-Q[i] <span class="comment"># cum sum of classes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	b1,b2 = np.hsplit(bins,[i]) <span class="comment"># weights</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># finding means and variances</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	m1,m2 = np.sum(p1*b1)/q1, np.sum(p2*b2)/q2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">	v1,v2 = np.sum(((b1-m1)**<span class="number">2</span>)*p1)/q1,np.sum(((b2-m2)**<span class="number">2</span>)*p2)/q2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># calculates the minimization function</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">	fn = v1*q1 + v2*q2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> fn &lt; fn_min:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">		fn_min = fn</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">		thresh = i</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># find otsu's threshold value with OpenCV function</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">ret, otsu = cv2.threshold(blur,<span class="number">0</span>,<span class="number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span> thresh,ret</span></pre></td></tr></table></figure>
<p>个人实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">otsu</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    sum_pix = img.size</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    th = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    mxdelta = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> t <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">256</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">        mask = img&lt;=t</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">        w0 = np.sum(mask)/sum_pix</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">        w1 = <span class="number">1</span> - w0</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> np.sum(mask!=<span class="number">0</span>)!=<span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">            k = img[mask]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">            u0 = np.mean(k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> :u0 = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> np.sum(mask!=<span class="number">0</span>)!=sum_pix:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">            k = img[(~mask)]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">            u1 = np.mean(k)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span> :u1 = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        delta = w0 * w1 * (u0-u1) ** <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> delta &gt; mxdelta :</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">            mxdelta = delta</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            th = t</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> th</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"material/9.png"</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">img = cv2.medianBlur(img,<span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">th = otsu(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">ret,dst = cv2.threshold(img,th,<span class="number">255</span>,cv2.THRESH_BINARY)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">ret2,dst2 = cv2.threshold(img,<span class="number">0</span>,<span class="number">255</span>,cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">print(ret,ret2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">"image"</span>,cv2.WINDOW_NORMAL)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">"image2"</span>,cv2.WINDOW_NORMAL)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"image"</span>,dst)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"image2"</span>,dst2)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">plt.hist(img.ravel(),<span class="number">256</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<h3 id="图像平滑"><a href="#图像平滑" class="headerlink" title="图像平滑"></a>图像平滑</h3><h4 id="2D-卷积"><a href="#2D-卷积" class="headerlink" title="$2D$卷积"></a>$2D$卷积</h4><p>​        与信号一样，我们也可以对 $2D$ 图像实施低通滤波$(LPF)$，高通滤波 $(HPF)$等。$LPF$ 帮助我们去除噪音，模糊图像。$HPF$ 帮助我们找到图像的边缘。</p>
<p>​        $OpenCV$ 提供的函数 <code>cv.filter2D()</code> 可以让我们对一幅图像进行卷积操作。下面将对一幅图像使用平均滤波器。下面是一个 $5*5$ 的平均滤波器核：</p>
<script type="math/tex; mode=display">
K = \frac{1}{25}
\begin{bmatrix}
1&1&1&1&1\\
1&1&1&1&1\\
1&1&1&1&1\\
1&1&1&1&1\\
1&1&1&1&1
\end{bmatrix}</script><p>​        操作如下：将核放在图像的一个像素 $A$ 上，求与核对应的图像上 $25(5*5)$ 个像素的和，在取平均数，用这个平均数替代像素 $A$ 的值。重复以上操作直到将图像的每一个像素值都更新一边。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'opencv_logo.png'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.float32)/<span class="number">25</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#cv.Filter2D(src, dst, kernel, anchor=(-1, -1))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#ddepth –desired depth of the destination image;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#if it is negative, it will be the same as src.depth();</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#the following combinations of src.depth() and ddepth are supported:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#src.depth() = CV_8U, ddepth = -1/CV_16S/CV_32F/CV_64F</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#src.depth() = CV_16U/CV_16S, ddepth = -1/CV_32F/CV_64F</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#src.depth() = CV_32F, ddepth = -1/CV_32F/CV_64F</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#src.depth() = CV_64F, ddepth = -1/CV_64F</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#when ddepth=-1, the output image will have the same depth as the source.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">dst = cv2.filter2D(img,<span class="number">-1</span>,kernel)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">'Original'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(dst),plt.title(<span class="string">'Averaging'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<h4 id="图像模糊（图像平滑）"><a href="#图像模糊（图像平滑）" class="headerlink" title="图像模糊（图像平滑）"></a>图像模糊（图像平滑）</h4><p>​        使用低通滤波器可以达到图像模糊的目的。这对与去除噪音很有帮助。其实就是去除图像中的高频成分（比如：噪音，边界）。所以边界也会被模糊一 点。（当然，也有一些模糊技术不会模糊掉边界）。$OpenCV $提供了四种模糊技术。</p>
<h5 id="平均"><a href="#平均" class="headerlink" title="平均"></a>平均</h5><p>​        这是由一个归一化卷积框完成的。他只是<strong>用卷积框覆盖区域所有像素的平均值来代替中心元素</strong>。可以使用函数 <code>cv2.blur()</code> 和 <code>cv2.boxFilter()</code> 来完成这个任务。可以同看查看文档了解更多卷积框的细节。我们需要设定卷积框的宽和高。下面是一个 $3 * 3$ 的归一化卷积框：</p>
<script type="math/tex; mode=display">
K = \frac{1}{9}
\begin{bmatrix}
1&1&1\\
1&1&1\\
1&1&1
\end{bmatrix}</script><p><strong>注意</strong>：<em>如果你不想使用归一化卷积框，你应该使用 <code>cv2.boxFilter()</code>，这时要 传入参数 <code>normalize=False</code>。(<code>cv2.blur</code>等价于· <code>normalize = ture</code> 的 <code>cv2.boxFilter</code>)</em></p>
<p>这是与上一个代码效果相同的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'opencv_logo.png'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">blur = cv2.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">121</span>),plt.imshow(img),plt.title(<span class="string">'Original'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">122</span>),plt.imshow(blur),plt.title(<span class="string">'Blurred'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<h5 id="高斯模糊"><a href="#高斯模糊" class="headerlink" title="高斯模糊"></a>高斯模糊</h5><p>​        现在把卷积核换成高斯核（简单来说，方框不变，将原来每个方框的值是相等的，现在里面的值是符合高斯分布的，方框中心的值最大，其余方框根据距离中心元素的距离递减，构成一个高斯小山包。原来的求平均数现在变成求加权平均数，全就是方框里的值）。实现的函数是 <code>cv2.GaussianBlur()</code>。我们需要指定高斯核的宽和高（必须是奇数）。以及高斯函数沿 $X，Y$ 方向的标准差。如果我们只指定了 $X$ 方向的的标准差，$Y$ 方向也会取相同值。如果两个标准差都是 0，那么函数会根据核函数的大小自己计算。高斯滤波可以有效的从图像中去除高斯噪音。 如果你愿意的话，你也可以使用函数 <code>cv2.getGaussianKernel()</code> 自己构建一个高斯核。 如果要使用高斯模糊的话，上边的代码应该写成：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#0 是指根据窗口大小（5,5）来计算高斯函数标准差</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">blur = cv2.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span></pre></td></tr></table></figure>
<h5 id="中值模糊"><a href="#中值模糊" class="headerlink" title="中值模糊"></a>中值模糊</h5><p>​        顾名思义就是用与卷积框对应像素的中值来替代中心像素的值。这个滤波器经常用来去除椒盐噪声。前面的滤波器都是用计算得到的一个新值来取代中心像素的值，而中值滤波是用中心像素周围（也可以使他本身）的值来取代他。 他能有效的去除噪声。卷积核的大小也应该是一个奇数。 </p>
<p>​        在这个例子中，我们给原始图像加上 $50\%$ 的噪声然后再使用中值模糊。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">median = cv2.medianBlur(img,<span class="number">5</span>)</span></pre></td></tr></table></figure>
<h5 id="双边滤波"><a href="#双边滤波" class="headerlink" title="双边滤波"></a>双边滤波</h5><p>​        函数 <code>cv2.bilateralFilter()</code> 能在保持边界清晰的情况下有效的去除噪音。但是这种操作与其他滤波器相比会比较慢。我们已经知道高斯滤波器是求中心点邻近区域像素的高斯加权平均值。这种高斯滤波器只考虑像素之间的空间关系，而不会考虑像素值之间的关系（像素的相似度）。所以这种方法不会考虑一个像素是否位于边界。因此边界也会别模糊掉，而这正不是我们想要。</p>
<p>​        双边滤波在同时使用空间高斯权重和灰度值相似性高斯权重。空间高斯函数确保只有邻近区域的像素对中心点有影响，灰度值相似性高斯函数确保只有与中心像素灰度值相近的才会被用来做模糊运算。所以这种方法会确保边界不会被模糊掉，因为边界处的灰度值变化比较大。</p>
<p>​        进行双边滤波的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#cv2.bilateralFilter(src, d, sigmaColor, sigmaSpace)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#d – Diameter of each pixel neighborhood that is used during filtering.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># If it is non-positive, it is computed from sigmaSpace</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#9 邻域直径，两个 75 分别是空间高斯函数标准差，灰度值相似性高斯函数标准差</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">blur = cv2.bilateralFilter(img,<span class="number">9</span>,<span class="number">75</span>,<span class="number">75</span>)</span></pre></td></tr></table></figure>
<p>比较</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"material/6.png"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">res = img</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">font = cv2.FONT_HERSHEY_SIMPLEX</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">tmp1 = cv2.blur(img,(<span class="number">5</span>,<span class="number">5</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">cv2.putText(tmp1,<span class="string">"blur"</span>,(<span class="number">10</span>,<span class="number">50</span>),font,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">tmp2 = cv2.GaussianBlur(img,(<span class="number">5</span>,<span class="number">5</span>),<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cv2.putText(tmp2,<span class="string">"Gaussian"</span>,(<span class="number">10</span>,<span class="number">50</span>),font,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">tmp3 = cv2.medianBlur(img,<span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">cv2.putText(tmp3,<span class="string">"median"</span>,(<span class="number">10</span>,<span class="number">50</span>),font,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">tmp4 = cv2.bilateralFilter(img,<span class="number">5</span>,<span class="number">75</span>,<span class="number">75</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">cv2.putText(tmp4,<span class="string">"bilateral"</span>,(<span class="number">10</span>,<span class="number">50</span>),font,<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">res = np.vstack((np.hstack((tmp1,tmp2)),np.hstack((tmp3,tmp4))))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">cv2.namedWindow(<span class="string">"image"</span>,cv2.WINDOW_NORMAL)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"image"</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"blur.png"</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/blur.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="形态学转换"><a href="#形态学转换" class="headerlink" title="形态学转换"></a>形态学转换</h3><p>​        形态学操作是根据图像形状进行的简单操作。一般情况下对二值化图像进行的操作。需要输入两个参数，一个是原始图像，第二个被称为<strong>结构化元素</strong>或<strong>核</strong>，它是用来决定操作的性质的。两个基本的形态学操作是<strong>腐蚀</strong>和<strong>膨胀</strong>。他们的变体构成了开运算，闭运算，梯度等。</p>
<h4 id="腐蚀"><a href="#腐蚀" class="headerlink" title="腐蚀"></a>腐蚀</h4><p>​        就像土壤侵蚀一样，这个操作会把前景物体的边界腐蚀掉（但是前景仍然是白色）。这是怎么做到的呢？卷积核沿着图像滑动，如果与卷积核对应的原图像的所有像素值都是 $1$，那么中心元素就保持原来的像素值，否则就变为零。 这回产生什么影响呢？根据卷积核的大小靠近前景的所有像素都会被腐蚀掉（变为 $0$），所以前景物体会变小，整幅图像的白色区域会减少。这对于去除白噪声很有用，也可以用来断开两个连在一块的物体等。 这里我们有一个例子，使用一个 $5*5$ 的卷积核，其中所有的值都是 $1$ 。让我们看看他是如何工作的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'j.png'</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#dst=cv2.erode(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]])</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">erosion = cv2.erode(img,kernel,iterations = <span class="number">1</span>)</span></pre></td></tr></table></figure>
<h4 id="膨胀"><a href="#膨胀" class="headerlink" title="膨胀"></a>膨胀</h4><p>​        与腐蚀相反，膨胀操作中只要与卷积核对应的原图像的像素值中只要有一个是 $1$，中心元素的像素值就是 $1$。所以这个操作会增加图像中的白色区域（前景）。一般在去噪声时先用腐蚀再用膨胀。因为腐蚀在去掉白噪声的同时，也会使前景对象变小。所以我们再对他进行膨胀。这时噪声已经被去除了，不会再回来了，但是前景还在并会增加。膨胀也可以用来连接两个分开的物体。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#dst=cv2.dilate(src, kernel[, dst[, anchor[, iterations[, borderType[, borderValue]]]]])</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">dilation = cv2.dilate(img,kernel,iterations = <span class="number">1</span>)</span></pre></td></tr></table></figure>
<ul>
<li>$src$：源图，通道数任意，深度需为$CV_8U$，$CV_16U$，$CV_16S$，$CV_32F$或 $CV_64F$</li>
<li>$dst$：输出图，与$src$有着同样的尺寸</li>
<li>$kernel$：膨胀操作的核，通常这个参数由函数<code>cv2.getStructuringElement</code>得到</li>
<li>$anchor$：锚点位置，默认值为中心点</li>
<li>$iterations$：自身迭代的次数，默认为1</li>
<li>$borderType$和$borderValue$都有各自的默认值，通常不用理会</li>
</ul>
<h4 id="开运算"><a href="#开运算" class="headerlink" title="开运算"></a>开运算</h4><p>​        先进行腐蚀再进行膨胀就叫做开运算。就像我们上面介绍的那样，它被用来去除噪声。这里我们用到的函数是 <code>cv2.morphologyEx()</code>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#dst=cv2.morphologyEx(src, op, kernel[, dst[, anchor[, iterations[, borderType[,borderValue]]]]])</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel)</span></pre></td></tr></table></figure>
<p><strong>op：操作标识符，即进行哪种操作，有下表（节选，注意将cv改为cv2）：</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/op.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="闭运算"><a href="#闭运算" class="headerlink" title="闭运算"></a>闭运算</h4><p>​        先膨胀再腐蚀。它经常被用来填充前景物体中的小洞，或者前景物体上的小黑点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel)</span></pre></td></tr></table></figure>
<p>其中开运算能够消除小物体，闭运算能够排除小黑色区域。</p>
<h4 id="形态学梯度"><a href="#形态学梯度" class="headerlink" title="形态学梯度"></a>形态学梯度</h4><p>​        其实就是一幅图像膨胀与腐蚀的差别。 </p>
<p>​        结果看上去就像前景物体的轮廓。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel)</span></pre></td></tr></table></figure>
<h4 id="礼帽"><a href="#礼帽" class="headerlink" title="礼帽"></a>礼帽</h4><p>​        原始图像与进行开运算之后得到的图像的差。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel)</span></pre></td></tr></table></figure>
<h4 id="黑帽"><a href="#黑帽" class="headerlink" title="黑帽"></a>黑帽</h4><p>​        进行闭运算之后得到的图像与原始图像的差。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel)</span></pre></td></tr></table></figure>
<h4 id="形态学操作之间的关系"><a href="#形态学操作之间的关系" class="headerlink" title="形态学操作之间的关系"></a>形态学操作之间的关系</h4><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://pllj.github.io/img/opencv/xtx.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="结构化元素"><a href="#结构化元素" class="headerlink" title="结构化元素"></a>结构化元素</h4><p>​        在前面的例子中我们使用 $Numpy$ 构建了结构化元素，它是正方形的。但有时我们需要构建一个椭圆形/圆形的核。为了实现这种要求，提供了 OpenCV 函数 <code>cv2.getStructuringElement()</code>。你只需要告诉他你需要的核的形状和大小。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Rectangular Kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv2.getStructuringElement(cv2.MORPH_RECT,(<span class="number">5</span>,<span class="number">5</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]], dtype=uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Elliptical Kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Cross-shaped Kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>cv2.getStructuringElement(cv2.MORPH_CROSS,(<span class="number">5</span>,<span class="number">5</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">array([[<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">       [<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>]], dtype=uint8)</span></pre></td></tr></table></figure>
<h3 id="图像梯度"><a href="#图像梯度" class="headerlink" title="图像梯度"></a>图像梯度</h3><p>​        梯度简单来说就是求导。 </p>
<p>​        OpenCV 提供了三种不同的梯度滤波器，或者说高通滤波器：$Sobel$， $Scharr$ 和 $Laplacian$。我们会一一介绍他们。 </p>
<p>​        $Sobel$，$Scharr$ 其实就是求一阶或二阶导数。$Scharr$ 是对 $Sobel$（使用小的卷积核求解求解梯度角度时）的优化。$Laplacian$ 是求二阶导数。</p>
<h4 id="Sobel-算子和-Scharr-算子"><a href="#Sobel-算子和-Scharr-算子" class="headerlink" title="$Sobel$ 算子和 $Scharr$ 算子"></a>$Sobel$ 算子和 $Scharr$ 算子</h4><p>​        $Sobel$ 算子是高斯平滑与微分操作的结合体，所以它的抗噪声能力很好。 你可以设定求导的方向（$xorder$ 或 $yorder$）。还可以设定使用的卷积核的大 小（$ksize$）。如果 $ksize=-1$，会使用 $3 <em> 3$ 的 $Scharr$ 滤波器，它的的效果要 比 $3 </em> 3$ 的 $Sobel$ 滤波器好（而且速度相同，所以在使用 $ 3<em>3 $ 滤波器时应该尽量使用 $Scharr$ 滤波器）。 $3</em>3$ 的 $Scharr$ 滤波器卷积核如下：</p>
<script type="math/tex; mode=display">
xorder:
\begin{array}{|c|c|c|}
\hline
-3&0&3\\
\hline
-10&0&10\\
\hline
-3&0&3\\
\hline
\end{array}
\\
yorder:
\begin{array}{|c|c|c|}
\hline
-3&-10&-3\\
\hline
0&0&0\\
\hline
3&10&3\\
\hline
\end{array}</script><h4 id="Laplacian-算子"><a href="#Laplacian-算子" class="headerlink" title="$Laplacian$ 算子"></a>$Laplacian$ 算子</h4><p>​        拉普拉斯算子可以使用二阶导数的形式定义，可假设其离散实现类似于二阶 $Sobel$ 导数，事实上，$OpenCV$ 在计算拉普拉斯算子时直接调用 $Sobel$ 算 子。计算公式如下：</p>
<script type="math/tex; mode=display">
\Delta src = \frac{\partial ^2 src}{\partial x^2}+\frac{\partial ^2 src}{\partial y^2}</script><p>​        拉普拉斯滤波器使用的卷积核：</p>
<script type="math/tex; mode=display">
karnel = 
\begin{bmatrix}
0&1&0\\
1&-4&1\\
0&1&0
\end{bmatrix}</script><p>​        下面的代码分别使用以上三种滤波器对同一幅图进行操作。使用的卷积核都是 $5 * 5$ 的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img=cv2.imread(<span class="string">'dave.jpg'</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#cv2.CV_64F 输出图像的深度（数据类型），可以使用-1, 与原图像保持一致 np.uint8</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">laplacian=cv2.Laplacian(img,cv2.CV_64F)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数 1,0 为只在 x 方向求一阶导数，最大可以求 2 阶导数。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">sobelx=cv2.Sobel(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数 0,1 为只在 y 方向求一阶导数，最大可以求 2 阶导数。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">sobely=cv2.Sobel(img,cv2.CV_64F,<span class="number">0</span>,<span class="number">1</span>,ksize=<span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>),plt.imshow(img,cmap = <span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">'Original'</span>), plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>),plt.imshow(laplacian,cmap = <span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">'Laplacian'</span>), plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>),plt.imshow(sobelx,cmap = <span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">'Sobel X'</span>), plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>),plt.imshow(sobely,cmap = <span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">'Sobel Y'</span>), plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<p><strong>注意</strong>：</p>
<p>​        在查看上面这个例子的注释时不知道你有没有注意到：我们可以通过参数 $-1$ 来设定输出图像的深度（数据类型）与原图像保持一致，但是我们在代码中使用的却是 $cv2.CV_64F$。这是为什么呢？想象一下一个从黑到白的边界的导数是整数，而一个从白到黑的边界点导数却是负数。如果原图像的深度是 $np.int8$ 时，所有的负值都会被截断变成 $0$，换句话说就是把把边界丢失掉。 所以如果这两种边界你都想检测到，最好的的办法就是将输出的数据类型 设置的更高，比如 $cv2.CV_16S$，$cv2.CV_64F$ 等。取绝对值然后再把它转回 到 $cv2.CV_8U$。下面的示例演示了输出图片的深度不同造成的不同效果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'boxs.png'</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Output dtype = cv2.CV_8U</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">sobelx8u = cv2.Sobel(img,cv2.CV_8U,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 也可以将参数设为-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#sobelx8u = cv2.Sobel(img,-1,1,0,ksize=5)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Output dtype = cv2.CV_64F. Then take its absolute and convert to cv2.CV_8U</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">sobelx64f = cv2.Sobel(img,cv2.CV_64F,<span class="number">1</span>,<span class="number">0</span>,ksize=<span class="number">5</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">abs_sobel64f = np.absolute(sobelx64f)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">sobel_8u = np.uint8(abs_sobel64f)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>),plt.imshow(img,cmap = <span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">'Original'</span>), plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>),plt.imshow(sobelx8u,cmap = <span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">'Sobel CV_8U'</span>), plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>),plt.imshow(sobel_8u,cmap = <span class="string">'gray'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">plt.title(<span class="string">'Sobel abs(CV_64F)'</span>), plt.xticks([]), plt.yticks([])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr></table></figure>
<h3 id="Canny边缘检测"><a href="#Canny边缘检测" class="headerlink" title="Canny边缘检测"></a>Canny边缘检测</h3><p>​        $Canny$ 边缘检测是一种非常流行的边缘检测算法，是 John F.Canny 在 1986 年提出的。它是一个有很多步构成的算法，我们接下来会逐步介绍。</p>
<h4 id="噪声去除"><a href="#噪声去除" class="headerlink" title="噪声去除"></a>噪声去除</h4><p>​        由于边缘检测很容易受到噪声影响，所以第一步是使用 $ 5 * 5 $ 的高斯滤波器去除噪声</p>
<h4 id="计算图像梯度"><a href="#计算图像梯度" class="headerlink" title="计算图像梯度"></a>计算图像梯度</h4><p>​        对平滑后的图像使用 $Sobel$ 算子计算水平方向和竖直方向的一阶导数（图像梯度）（$Gx$ 和 $Gy$）。根据得到的这两幅梯度图（$Gx$ 和 $Gy$）找到边界的梯度和方向，公式如下：</p>
<script type="math/tex; mode=display">
Edge\_Gradient(G)=\sqrt{G^2_x+G^2_y}\\
Angle(\theta) = \tan ^{-1}(\frac{G_x}{G_y})</script><p>​        梯度的方向一般总是与边界垂直。梯度方向被归为四类：垂直，水平，和两个对角线。</p>
<h4 id="非极大值抑制"><a href="#非极大值抑制" class="headerlink" title="非极大值抑制"></a>非极大值抑制</h4><p>​        在获得梯度的方向和大小之后，应该对整幅图像做一个扫描，去除那些非 边界上的点。对每一个像素进行检查，看这个点的梯度是不是周围具有相同梯度方向的点中最大的。如下图所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/cannyhold.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>​        $A$点在边界上（垂直方向），梯度方向是边界的法向量。点$B$和点$C$在梯度方向上面，所以点$A$检测点$B$和$C$是否形成了本地最大值，如果形成最大值，那么就进行下一步，否则进行抑制（赋值为0）<br>​        简单的说，现在得到的是一个包含“窄边界”的二值图像。</p>
<h4 id="滞后阈值"><a href="#滞后阈值" class="headerlink" title="滞后阈值"></a>滞后阈值</h4><p>​        现在要确定那些边界才是真正的边界。这时我们需要设置两个阈值： $minVal$ 和 $maxVal$。当图像的灰度梯度高于 $maxVal$ 时被认为是真的边界， 那些低于 $minVal$ 的边界会被抛弃。如果介于两者之间的话，就要看这个点是 否与某个被确定为真正的边界点相连，如果是就认为它也是边界点，如果不是就抛弃。如下图：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/mnthresh.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>​        $A$ 高于阈值 $maxVal$ 所以是真正的边界点，$C$ 虽然低于 $maxVal$ 但高于 $minVal$ 并且与 A 相连，所以也被认为是真正的边界点。而 $B$ 就会被抛弃，因 为他不仅低于 $maxVal$ 而且不与真正的边界点相连。所以选择合适的 $maxVal$ 和 $minVal$ 对于能否得到好的结果非常重要。 在这一步一些小的噪声点也会被除去，因为我们假设边界都是一些长的线段。</p>
<p>实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">m1 = np.array([[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>],[<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">m2 = np.array([[<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步：完成高斯平滑滤波</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"rice.jpg"</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">img = cv2.GaussianBlur(img,(<span class="number">3</span>,<span class="number">3</span>),<span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第二步：完成一阶有限差分计算，计算每一点的梯度幅值与方向</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">img1 = np.zeros(img.shape,dtype=<span class="string">"uint8"</span>) <span class="comment"># 与原图大小相同</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">theta = np.zeros(img.shape,dtype=<span class="string">"float"</span>)  <span class="comment"># 方向矩阵原图像大小</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">img = cv2.copyMakeBorder(img,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,borderType=cv2.BORDER_REPLICATE)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">rows,cols = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,rows<span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,cols<span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># Gy</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">        Gy = (np.dot(np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]), (m1 * img[i - <span class="number">1</span>:i + <span class="number">2</span>, j - <span class="number">1</span>:j + <span class="number">2</span>]))).dot(np.array([[<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">1</span>]]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">        <span class="comment"># Gx</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        Gx = (np.dot(np.array([<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]), (m2 * img[i - <span class="number">1</span>:i + <span class="number">2</span>, j - <span class="number">1</span>:j + <span class="number">2</span>]))).dot(np.array([[<span class="number">1</span>], [<span class="number">1</span>], [<span class="number">1</span>]]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> Gx[<span class="number">0</span>] == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">            theta[i<span class="number">-1</span>,j<span class="number">-1</span>] = <span class="number">90</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">            temp = (np.arctan(Gy[<span class="number">0</span>] / Gx[<span class="number">0</span>]) ) * <span class="number">180</span> / np.pi</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> Gx[<span class="number">0</span>]*Gy[<span class="number">0</span>] &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> Gx[<span class="number">0</span>] &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">                theta[i<span class="number">-1</span>,j<span class="number">-1</span>] = np.abs(temp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">                theta[i<span class="number">-1</span>,j<span class="number">-1</span>] = (np.abs(temp) - <span class="number">180</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> Gx[<span class="number">0</span>] * Gy[<span class="number">0</span>] &lt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> Gx[<span class="number">0</span>] &gt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">                theta[i<span class="number">-1</span>,j<span class="number">-1</span>] = (<span class="number">-1</span>) * np.abs(temp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">                theta[i<span class="number">-1</span>,j<span class="number">-1</span>] = <span class="number">180</span> - np.abs(temp)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        img1[i<span class="number">-1</span>,j<span class="number">-1</span>] = (np.sqrt(Gx**<span class="number">2</span> + Gy**<span class="number">2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,rows - <span class="number">2</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, cols - <span class="number">2</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (    ( (theta[i,j] &gt;= <span class="number">-22.5</span>) <span class="keyword">and</span> (theta[i,j]&lt; <span class="number">22.5</span>) ) <span class="keyword">or</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">                ( (theta[i,j] &lt;= <span class="number">-157.5</span>) <span class="keyword">and</span> (theta[i,j] &gt;= <span class="number">-180</span>) ) <span class="keyword">or</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">                ( (theta[i,j] &gt;= <span class="number">157.5</span>) <span class="keyword">and</span> (theta[i,j] &lt; <span class="number">180</span>) ) ):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">            theta[i,j] = <span class="number">0.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">elif</span> (    ( (theta[i,j] &gt;= <span class="number">22.5</span>) <span class="keyword">and</span> (theta[i,j]&lt; <span class="number">67.5</span>) ) <span class="keyword">or</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">                ( (theta[i,j] &lt;= <span class="number">-112.5</span>) <span class="keyword">and</span> (theta[i,j] &gt;= <span class="number">-157.5</span>) ) ):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">            theta[i,j] = <span class="number">45.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">elif</span> (    ( (theta[i,j] &gt;= <span class="number">67.5</span>) <span class="keyword">and</span> (theta[i,j]&lt; <span class="number">112.5</span>) ) <span class="keyword">or</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">                ( (theta[i,j] &lt;= <span class="number">-67.5</span>) <span class="keyword">and</span> (theta[i,j] &gt;= <span class="number">-112.5</span>) ) ):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">            theta[i,j] = <span class="number">90.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">elif</span> (    ( (theta[i,j] &gt;= <span class="number">112.5</span>) <span class="keyword">and</span> (theta[i,j]&lt; <span class="number">157.5</span>) ) <span class="keyword">or</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">                ( (theta[i,j] &lt;= <span class="number">-22.5</span>) <span class="keyword">and</span> (theta[i,j] &gt;= <span class="number">-67.5</span>) ) ):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">            theta[i,j] = <span class="number">-45.0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第三步：进行 非极大值抑制计算</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">img2 = np.zeros(img1.shape) <span class="comment"># 非极大值抑制图像矩阵</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,img2.shape[<span class="number">0</span>]<span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,img2.shape[<span class="number">1</span>]<span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (theta[i,j] == <span class="number">0.0</span>) <span class="keyword">and</span> (img1[i,j] == np.max([img1[i,j],img1[i+<span class="number">1</span>,j],img1[i<span class="number">-1</span>,j]]) ):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">                img2[i,j] = img1[i,j]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (theta[i,j] == <span class="number">-45.0</span>) <span class="keyword">and</span> img1[i,j] == np.max([img1[i,j],img1[i<span class="number">-1</span>,j<span class="number">-1</span>],img1[i+<span class="number">1</span>,j+<span class="number">1</span>]]):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">                img2[i,j] = img1[i,j]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (theta[i,j] == <span class="number">90.0</span>) <span class="keyword">and</span>  img1[i,j] == np.max([img1[i,j],img1[i,j+<span class="number">1</span>],img1[i,j<span class="number">-1</span>]]):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">                img2[i,j] = img1[i,j]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (theta[i,j] == <span class="number">45.0</span>) <span class="keyword">and</span> img1[i,j] == np.max([img1[i,j],img1[i<span class="number">-1</span>,j+<span class="number">1</span>],img1[i+<span class="number">1</span>,j<span class="number">-1</span>]]):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">                img2[i,j] = img1[i,j]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第四步：双阈值检测和边缘连接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">img3 = np.zeros(img2.shape) <span class="comment">#定义双阈值图像</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># TL = 0.4*np.max(img2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># TH = 0.5*np.max(img2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">TL = <span class="number">50</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">TH = <span class="number">100</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#关键在这两个阈值的选择</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,img3.shape[<span class="number">0</span>]<span class="number">-1</span>): </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>,img3.shape[<span class="number">1</span>]<span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> img2[i,j] &lt; TL:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">            img3[i,j] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">elif</span> img2[i,j] &gt; TH:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">            img3[i,j] = <span class="number">255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">elif</span> (( img2[i+<span class="number">1</span>,j] &lt; TH) <span class="keyword">or</span> (img2[i<span class="number">-1</span>,j] &lt; TH )<span class="keyword">or</span>( img2[i,j+<span class="number">1</span>] &lt; TH )<span class="keyword">or</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">                (img2[i,j<span class="number">-1</span>] &lt; TH) <span class="keyword">or</span> (img2[i<span class="number">-1</span>, j<span class="number">-1</span>] &lt; TH )<span class="keyword">or</span> ( img2[i<span class="number">-1</span>, j+<span class="number">1</span>] &lt; TH) <span class="keyword">or</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">                   ( img2[i+<span class="number">1</span>, j+<span class="number">1</span>] &lt; TH ) <span class="keyword">or</span> ( img2[i+<span class="number">1</span>, j<span class="number">-1</span>] &lt; TH) ):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">            img3[i,j] = <span class="number">255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"1"</span>,img)  		  <span class="comment"># 原始图像</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"2"</span>,img1)       <span class="comment"># 梯度幅值图</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"3"</span>,img2)       <span class="comment">#非极大值抑制灰度图</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"4"</span>,img3)       <span class="comment"># 最终效果图</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"theta"</span>,theta) <span class="comment">#角度值灰度图</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">————————————————</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">版权声明：本文为CSDN博主「飘云之下」的原创文章，遵循 CC <span class="number">4.0</span> BY-SA 版权协议，转载请附上原文出处链接及本声明。</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">原文链接：https://blog.csdn.net/weixin_44403952/article/details/<span class="number">90375013</span></span></pre></td></tr></table></figure>
<h4 id="OpenCV-中的-Canny-边界检测"><a href="#OpenCV-中的-Canny-边界检测" class="headerlink" title="OpenCV 中的 Canny 边界检测"></a>OpenCV 中的 Canny 边界检测</h4><p>​        在 OpenCV 中只需要一个函数：<code>cv2.Canny()</code>，就可以完成以上几步。 让我们看如何使用这个函数。这个函数的第一个参数是输入图像。第二和第三个分别是 $minVal$ 和 $maxVal$。第三个参数设置用来计算图像梯度的 $Sobel$ 卷积核的大小，默认值为 $3$。最后一个参数是 $L2gradient$，它可以用来设定 求梯度大小的方程。如果设为 $True$，就会使用我们上面提到过的方程，否则使用方程：$Edge_Gradient(G) = |G^2_x | + |G^2_y | $代替，默认值为 $False$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"material/dlam.jpg"</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">res = cv2.Canny(img,<span class="number">100</span>,<span class="number">200</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">res = np.hstack((img,res))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"image"</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"canny.png"</span>,res)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/canny.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="图像金字塔"><a href="#图像金字塔" class="headerlink" title="图像金字塔"></a>图像金字塔</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>​        一般情况下，我们要处理是一副具有固定分辨率的图像。但是有些情况下， 我们需要对同一图像的不同分辨率的子图像进行处理。比如，我们要在一幅图像中查找某个目标，比如脸，我们不知道目标在图像中的尺寸大小。这种情况下，我们需要创建创建一组图像，这些图像是具有不同分辨率的原始图像。我们把这组图像叫做图像金字塔（简单来说就是同一图像的不同分辨率的子图集合）。如果我们把最大的图像放在底部，最小的放在顶部，看起来像一座金字塔，故而得名图像金字塔。 </p>
<p>​        有两类图像金字塔：<strong>高斯金字塔</strong>和<strong>拉普拉斯金字塔</strong>。高斯金字塔的顶部是通过将底部图像中的连续的行和列去除得到的。顶部图像中的每个像素值等于下面一层图像中 <strong>5 个像素的高斯加权平均值</strong>。这样操作一次一个 $M <em> N$ 的图像就变成了一个 $\frac{M}{2}</em>\frac{N}{2}$ 的图像。所以这幅图像的面积就变为原来图像面积的四分之一。这被称为 $Octave$。连续进行这样的操作我们就会得到一个分辨率不断下降的图像金字塔。我们可以使用函数 <code>cv2.pyrDown()</code> 和 <code>cv2.pyrUp()</code> 构建图像金字塔。 函数 <code>cv2.pyrDown()</code> 从一个高分辨率大尺寸的图像向上构建一个金子塔 （尺寸变小，分辨率降低），即一旦使用 <code>cv2.pyrDown()</code>，图像的分辨率就会降低，信息就会被丢失。</p>
<p>对图像的向下取样操作，即缩小图像，方法步骤如下：</p>
<ol>
<li><p>对图像G_i进行高斯内核卷积，进行高斯模糊；</p>
</li>
<li><p>将所有偶数行和列去除。</p>
</li>
</ol>
<p>对图像的向上取样，即放大图像，方法步骤如下：</p>
<ol>
<li><p>将图像在每个方向扩大为原来的两倍，新增的行和列以0填充</p>
</li>
<li><p>使用先前同样的内核(乘以4)与放大后的图像卷积，获得 “新增像素”的近似值</p>
</li>
</ol>
<p>拉普拉斯金字塔可以有高斯金字塔计算得来，公式如下：</p>
<script type="math/tex; mode=display">
L_i=G_i-PyrUp(G_{i+1})</script><p>拉普拉金字塔的图像看起来就像边界图，其中很多像素都是 0。他们经常被用在图像压缩中。</p>
<h4 id="使用金字塔进行图像融合"><a href="#使用金字塔进行图像融合" class="headerlink" title="使用金字塔进行图像融合"></a>使用金字塔进行图像融合</h4><p>​        图像金字塔的一个应用是图像融合。例如，在图像缝合中，你需要将两幅图叠在一起，但是由于连接区域图像像素的不连续性，整幅图的效果看起来会很差。这时图像金字塔就可以排上用场了，他可以帮你实现无缝连接。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img1 = cv2.imread(<span class="string">"material/s3.jfif"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img2 = cv2.imread(<span class="string">"material/s2.jfif"</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">h,w,d = img2.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">print(h,w)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">img1 = cv2.resize(img1,(w,h),cv2.INTER_AREA)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">G = img1.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">gpa = [G]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    G = cv2.pyrDown(G)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    gpa.append(G)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">G = img2.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">gpb = [G]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    G = cv2.pyrDown(G)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    gpb.append(G)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">lpa = [gpa[<span class="number">5</span>]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>,<span class="number">0</span>,<span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    GE = cv2.pyrUp(gpa[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    L = cv2.subtract(gpa[i<span class="number">-1</span>],GE)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    lpa.append(L)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">lpb = [gpb[<span class="number">5</span>]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>,<span class="number">0</span>,<span class="number">-1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    GE = cv2.pyrUp(gpb[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    L = cv2.subtract(gpb[i<span class="number">-1</span>],GE)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    lpb.append(L)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">LS = []</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> la,lb <span class="keyword">in</span> zip(lpa,lpb):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    h,w,d = la.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    ls = np.vstack((la[<span class="number">0</span>:h//<span class="number">2</span>,:],lb[h//<span class="number">2</span>:,:]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    LS.append(ls)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">ls = LS[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    ls = cv2.pyrUp(ls)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    ls = cv2.add(ls,LS[i])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">h,w,d = img1.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">real = np.vstack((img1[:h//<span class="number">2</span>,:],img2[h//<span class="number">2</span>:,:]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"real"</span>,real)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"merge"</span>,ls)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"real.jpg"</span>,real)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"blending.jpg"</span>,ls)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/blending.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="OpenCV-中的轮廓"><a href="#OpenCV-中的轮廓" class="headerlink" title="OpenCV 中的轮廓"></a>OpenCV 中的轮廓</h3><h4 id="什么是轮廓"><a href="#什么是轮廓" class="headerlink" title="什么是轮廓"></a>什么是轮廓</h4><p>轮廓可以简单认为成将连续的点（连着边界）连在一起的曲线，具有相同的颜色或者灰度。轮廓在形状分析和物体的检测和识别中很有用。</p>
<ul>
<li>为了更加准确，要使用二值化图像。在寻找轮廓之前，要进行<strong>阈值化处理</strong>或者 <strong>Canny 边界检测</strong>。</li>
<li>查找轮廓的函数会<strong>修改原始图像</strong>。如果你在找到轮廓之后还想使用原始图像的话，你应该<strong>将原始图像存储到其他变量中</strong>。</li>
<li>在 OpenCV 中，查找轮廓就像<strong>在黑色背景中找白色物体</strong>。你应该记住， <strong>要找的物体应该是白色而背景应该是黑色</strong>。</li>
</ul>
<p>让我们看看如何在一个二值图像中查找轮廓： </p>
<p>​        函数 <code>cv2.findContours()</code> 有三个参数，第一个是<strong>输入图像</strong>，第二个是<strong>轮廓检索模式</strong>，第三个是<strong>轮廓近似方法</strong>。返回值有三个，第一个是<strong>图像</strong>，第二个是<strong>轮廓</strong>，第三个是<strong>（轮廓的）层析结构</strong>。轮廓（第二个返回值）是一个 Python 列表，其中存储这图像中的所有轮廓。每一个轮廓都是一个 $Numpy$ 数组，包含对象边界点$(x，y)$的坐标。</p>
<p><strong>注意</strong>：<em>我们后边会对第二和第三个参数，以及层次结构进行详细介绍。在那之前，例子中使用的参数值对所有图像都是适用的。</em></p>
<h4 id="怎样绘制轮廓"><a href="#怎样绘制轮廓" class="headerlink" title="怎样绘制轮廓"></a>怎样绘制轮廓</h4><p>​        函数 <code>cv2.drawContours()</code> 可以被用来绘制轮廓。它可以根据你提供的边界点绘制任何形状。它的第一个参数是原始图像，第二个参数是轮廓，一个 $Python$ 列表。第三个参数是轮廓的索引（在绘制独立轮廓是很有用，当设置为 $-1$ 时绘制所有轮廓）。接下来的参数是轮廓的颜色和厚度等。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">im = cv2.imread(<span class="string">'material/bk.jpg'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">imgray = cv2.cvtColor(im,cv2.COLOR_BGR2GRAY)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">ret,thresh = cv2.threshold(imgray,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">contours, hierarchy = cv2.findContours(thresh,cv2.RETR_TREE,cv2.CHAIN_APPROX_SIMPLE)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">bi = np.zeros(im.shape,np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">imag = cv2.drawContours(bi,contours,<span class="number">-1</span>,(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>),<span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"image"</span>,imag)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<h4 id="轮廓的近似方法"><a href="#轮廓的近似方法" class="headerlink" title="轮廓的近似方法"></a>轮廓的近似方法</h4><p>​        这是函数 <code>cv2.findCountours()</code> 的第三个参数。它到底代表什么意思呢？</p>
<p>​        上边我们已经提到轮廓是一个形状具有相同灰度值的边界。它会存贮形状边界上所有的 $(x,y)$ 坐标。但是需要将所有的这些边界点都存储吗？这就是这个参数要告诉函数 <code>cv2.findContours</code> 的。 这个参数如果被设置为 <code>cv2.CHAIN_APPROX_NONE</code>，所有的边界点都会被存储。但当我们找的边界是一条直线时，我们只需要这条直线的两个端点。这就是 <code>cv2.CHAIN_APPROX_SIMPLE</code> 要做的。它会将轮廓上的冗余点都去掉，压缩轮廓，从而节省内存开支。</p>
<h3 id="轮廓特征"><a href="#轮廓特征" class="headerlink" title="轮廓特征"></a>轮廓特征</h3><h4 id="矩"><a href="#矩" class="headerlink" title="矩"></a>矩</h4><p>​        图像的矩可以帮助我们计算图像的质心，面积等</p>
<p>​        函数 <code>cv2.moments()</code> 会将计算得到的矩以一个字典的形式返回。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">'star.jpg'</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">ret,thresh = cv2.threshold(img,<span class="number">127</span>,<span class="number">255</span>,<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">contours,hierarchy = cv2.findContours(thresh, <span class="number">1</span>, <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">cnt = contours[<span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">M = cv2.moments(cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">print(M)</span></pre></td></tr></table></figure>
<p>根据这些矩的值，我们可以计算出对象的重：$C_x = \frac{M_{10}}{M_{00}} ，Cy = \frac{M_{01}}{M_{00}}$ 。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cx = int(M[<span class="string">'m10'</span>]/M[<span class="string">'m00'</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cy = int(M[<span class="string">'m01'</span>]/M[<span class="string">'m00'</span>])</span></pre></td></tr></table></figure>
<h4 id="轮廓面积"><a href="#轮廓面积" class="headerlink" title="轮廓面积"></a>轮廓面积</h4><p>轮廓的面积可以使用函数 <code>cv2.contourArea()</code> 计算得到，也可以使用矩 ( $0$ 阶矩)，$M[‘m00’]$。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span></pre></td></tr></table></figure>
<h4 id="轮廓周长"><a href="#轮廓周长" class="headerlink" title="轮廓周长"></a>轮廓周长</h4><p>​        也被称为弧长。可以使用函数 <code>cv2.arcLength()</code> 计算得到。这个函数的第二参数可以用来指定对象的形状是闭合的$(True)$，还是打开的（一条曲线）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">perimeter = cv2.arcLength(cnt,<span class="literal">True</span>)</span></pre></td></tr></table></figure>
<h4 id="轮廓近似"><a href="#轮廓近似" class="headerlink" title="轮廓近似"></a>轮廓近似</h4><p>​        将轮廓形状近似到另外一种由更少点组成的轮廓形状，新轮廓的点的数目由我们设定的准确度来决定。使用的<strong>$Douglas-Peucker$算法</strong>。 为了帮助理解，假设我们要在一幅图像中查找一个矩形，但是由于图像的种种原因，我们不能得到一个完美的矩形，而是一个“坏形状”。 现在就可以使用这个函数来近似这个形状了。这个函数的第二个参数叫 $epsilon$，它是从原始轮廓到近似轮廓的最大距离。它是一个准确度参数。选择一个好的 $epsilon$ 对于得到满意结果非常重要；第三个参数设定弧线是否闭合。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">epsilon=<span class="number">0.1</span>*cv2.arcLength(cnt,<span class="literal">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">approx= cv2.approxPolyDP(cnt,epsilon,<span class="literal">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">temp = cv2.cvtColor(image.copy(), cv2.COLOR_GRAY2BGR)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">cv2.drawContours(temp, [approx], <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">epsilon2=<span class="number">0.01</span>*cv2.arcLength(cnt,<span class="literal">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">approx2= cv2.approxPolyDP(cnt,epsilon2,<span class="literal">True</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">temp2 = cv2.cvtColor(image.copy(), cv2.COLOR_GRAY2BGR)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cv2.drawContours(temp2, [approx2], <span class="number">-1</span>, (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">231</span>),plt.imshow(img,<span class="string">'gray'</span>),plt.title(<span class="string">'original'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">232</span>),plt.imshow(temp,<span class="string">'gray'</span>),plt.title(<span class="string">' epsilon = 10%'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">plt.subplot(<span class="number">233</span>),plt.imshow(temp2,<span class="string">'gray'</span>),plt.title(<span class="string">' epsilon = 1%'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">plt.show()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">作者：Zoe_C</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">链接：https://www.jianshu.com/p/<span class="number">2</span>b60802306a8</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">来源：简书</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/caprox.webp" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="凸包"><a href="#凸包" class="headerlink" title="凸包"></a>凸包</h4><p>​        凸包与轮廓近似相似，但不同，虽然有些情况下它们给出的结果是一样的。 函数 <code>cv2.convexHull()</code> 可以用来检测一个曲线是否具有凸性缺陷，并能纠正缺陷。一般来说，凸性曲线总是凸出来的，至少是平的。如果有地方凹进去就被叫做凸性缺陷。例如下图中的手。红色曲线显示了手的凸包，凸性缺陷被双箭头标出来了。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/tb.webp" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>​        关于他的语法还有一些需要交代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(points[, hull[, clockwise[, returnPoints]]</span></pre></td></tr></table></figure>
<p>参数： </p>
<ul>
<li>$points$ 我们要传入的轮廓</li>
<li>$hull$ 输出，通常不需要</li>
<li>$clockwise$ 方向标志。如果设置为 $True$，输出的凸包是顺时针方向的。 否则为逆时针方向。</li>
<li>$returnPoints$ 默认值为 $True$。它会返回凸包上点的坐标。如果设置为 $False$，就会返回与凸包点对应的轮廓上的点。</li>
</ul>
<p>要获得上图的凸包，下面的命令就够了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(cnt)</span></pre></td></tr></table></figure>
<p>​        但是如果你想获得凸性缺陷，需要把 $returnPoints$ 设置为 $False$。以 上面的矩形为例，首先我们找到他的轮廓 $cnt$。现在我把 $returnPoints$ 设置 为 True 查找凸包，我得到下列值：</p>
<p>​        $[[[234 \space 202]], [[ 51 \space 202]], [[ 51 \space 79]], [[234 \space 79]]]$，其实就是矩形的四个角点。 </p>
<p>​        现在把 $returnPoints$ 设置为 $False$，得到的结果是 $[[129],[ 67],[ 0],[142]]$ </p>
<p>​        他们是轮廓点的索引。例如：$cnt[129] = [[234, 202]]$，这与前面我们得到结果的第一个值是一样的。 在凸检验中还会遇到这些。</p>
<h4 id="凸性检测"><a href="#凸性检测" class="headerlink" title="凸性检测"></a>凸性检测</h4><p>​        函数 <code>cv2.isContourConvex()</code>可以可以用来检测<strong>一个曲线是不是凸的</strong>。它只能返回 $True$ 或 $False$。没什么大不了的。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">k = cv2.isContourConvex(cnt)</span></pre></td></tr></table></figure>
<h4 id="边界矩形"><a href="#边界矩形" class="headerlink" title="边界矩形"></a>边界矩形</h4><p>有两类边界矩形。</p>
<p><strong>直边界矩形</strong>        一个直矩形（就是没有旋转的矩形）。它不会考虑对象是否旋转。所以边界矩形的面积不是最小的。可以使用函数<code>cv2.boundingRect()</code> 查找得到。<br>        $(x,y)$为矩形左上角的坐标，$(w,h)$是矩形的宽和高。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">x,y,w,h = cv2.boundingRect(cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">img = cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span></pre></td></tr></table></figure>
<p><strong>旋转的边界矩形</strong>        这个边界矩形是面积最小的，因为它考虑了对象的旋转。用的函数为<code>cv2.minAreaRect()</code>。返回的是一个$Box2D$ 结构，其中包含矩形左上角角点的坐标$(x,y)$，矩形的宽和高$(w,h)$，以及旋转角度。但是要绘制这个矩形需要矩形的 $4$ 个角点，可以通过函数<code>cv2.boxPoints()</code> 获得。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">rect = cv2.minAreaRect(cnt)<span class="comment">#计算最小矩形区域</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">box = cv2.boxPoints(rect)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">box = np.int0(box)<span class="comment">#浮点型转为整形</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">cv2.drawContours(im, [box], <span class="number">0</span>, (<span class="number">0</span>,<span class="number">0</span>,<span class="number">255</span>), <span class="number">3</span>)</span></pre></td></tr></table></figure>
<p>把这两中边界矩形显示在下图中，其中绿色的为直矩形，红的为旋转矩形。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/rc.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="最小外接圆"><a href="#最小外接圆" class="headerlink" title="最小外接圆"></a>最小外接圆</h4><p>​        函数<code>cv2.minEnclosingCircle()</code> 可以帮我们找到一个对象的外切圆。它是所有能够包括对象的圆中面积最小的一个。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(x,y),radius = cv2.minEnclosingCircle(cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">center = (int(x),int(y))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">radius = int(radius)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">img = cv2.circle(img,center,radius,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/cmc.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h4 id="椭圆拟合"><a href="#椭圆拟合" class="headerlink" title="椭圆拟合"></a>椭圆拟合</h4><p>​        使用的函数为<code>cv2.fitEllipse()</code>，返回值其实就是<strong>旋转边界矩形的内切圆</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">ellipse = cv2.fitEllipse(cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">im = cv2.ellipse(im,ellipse,(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span></pre></td></tr></table></figure>
<h4 id="直线拟合"><a href="#直线拟合" class="headerlink" title="直线拟合"></a>直线拟合</h4><p>​        我们可以根据一组点拟合出一条直线，同样我们也可以为图像中的白色点拟合出一条直线。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">rows,cols = img.shape[:<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#cv2.fitLine(points, distType, param, reps, aeps[, line ]) → line</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#points – Input vector of 2D or 3D points, stored in std::vector&lt;&gt; or Mat.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#line – Output line parameters. In case of 2D fitting, it should be a vector of</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#4 elements (likeVec4f) - (vx, vy, x0, y0), where (vx, vy) is a normalized</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#vector collinear to the line and (x0, y0) is a point on the line. In case of</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#3D fitting, it should be a vector of 6 elements (like Vec6f) - (vx, vy, vz,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#x0, y0, z0), where (vx, vy, vz) is a normalized vector collinear to the line</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#and (x0, y0, z0) is a point on the line.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#distType – Distance used by the M-estimator</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#distType=CV_DIST_L2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#ρ(r) = r2 /2 (the simplest and the fastest least-squares method)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#param – Numerical parameter ( C ) for some types of distances. If it is 0, an optimal value</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#is chosen.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#reps – Sufficient accuracy for the radius (distance between the coordinate origin and the</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#line).</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#aeps – Sufficient accuracy for the angle. 0.01 would be a good default value for reps and</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#aeps.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">[vx,vy,x,y] = cv2.fitLine(cnt, cv2.DIST_L2,<span class="number">0</span>,<span class="number">0.01</span>,<span class="number">0.01</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">lefty = int((-x*vy/vx) + y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">righty = int(((cols-x)*vy/vx)+y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">img = cv2.line(img,(cols<span class="number">-1</span>,righty),(<span class="number">0</span>,lefty),(<span class="number">0</span>,<span class="number">255</span>,<span class="number">0</span>),<span class="number">2</span>)</span></pre></td></tr></table></figure>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://pllj.github.io/img/opencv/cl.jpg" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h3 id="轮廓的性质"><a href="#轮廓的性质" class="headerlink" title="轮廓的性质"></a>轮廓的性质</h3><h5 id="长宽比"><a href="#长宽比" class="headerlink" title="长宽比"></a>长宽比</h5><p>​        边界矩形的宽高比</p>
<script type="math/tex; mode=display">
Aspect \space Ration = \frac{Width}{Height}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">x,y,w,h = cv2.boundingRect(cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">aspect_ratio = float(w)/h</span></pre></td></tr></table></figure>
<h5 id="Extent"><a href="#Extent" class="headerlink" title="Extent"></a>Extent</h5><p>​        轮廓面积与边界矩形面积的比。</p>
<script type="math/tex; mode=display">
Extent = \frac{Object \space Area}{Bounding \space Rectangle \space Area}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">x,y,w,h = cv2.boundingRect(cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">rect_area = w*h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">extent = float(area)/rect_area</span></pre></td></tr></table></figure>
<h5 id="Solidity"><a href="#Solidity" class="headerlink" title="Solidity"></a>Solidity</h5><p>​        轮廓面积与凸包面积的比。</p>
<script type="math/tex; mode=display">
Solidity =\frac{Contour \space Area}{ConvexHull \space Area}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">hull = cv2.convexHull(cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">hull_area = cv2.contourArea(hull)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">solidity = float(area)/hull_area</span></pre></td></tr></table></figure>
<h5 id="Equivalent-Diameter"><a href="#Equivalent-Diameter" class="headerlink" title="Equivalent Diameter"></a>Equivalent Diameter</h5><p>​        与轮廓面积相等的圆形的直径。</p>
<script type="math/tex; mode=display">
Equivalent \space Diameter = \sqrt{\frac{4 \times Contour \space Area}{\pi}}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">area = cv2.contourArea(cnt)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">equi_diameter = np.sqrt(<span class="number">4</span>*area/np.pi)</span></pre></td></tr></table></figure>
<h5 id="方向"><a href="#方向" class="headerlink" title="方向"></a>方向</h5><p>​        对象的方向，下面的方法还会返回长轴和短轴的长度</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">(x,y),(MA,ma),angle = cv2.fitEllipse(cnt)</span></pre></td></tr></table></figure>
<h5 id="掩模和像素点"><a href="#掩模和像素点" class="headerlink" title="掩模和像素点"></a>掩模和像素点</h5><p>​        有时我们需要构成对象的所有像素点，我们可以这样做：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mask = np.zeros(imgray.shape,np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这里一定要使用参数-1, 绘制填充的的轮廓</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">cv2.drawContours(mask,[cnt],<span class="number">0</span>,<span class="number">255</span>,<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#Returns a tuple of arrays, one for each dimension of a,</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#containing the indices of the non-zero elements in that dimension.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#The result of this is always a 2-D array, with a row for</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#each non-zero element.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#To group the indices by element, rather than dimension, use:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#transpose(nonzero(a))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; x = np.eye(3)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; x</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#array([[ 1., 0., 0.],</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># [ 0., 1., 0.],</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># [ 0., 0., 1.]])</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; np.nonzero(x)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#(array([0, 1, 2]), array([0, 1, 2]))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; x[np.nonzero(x)]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#array([ 1., 1., 1.])</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#&gt;&gt;&gt; np.transpose(np.nonzero(x))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#array([[0, 0],</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># [1, 1],</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># [2, 2]])</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">pixelpoints = np.transpose(np.nonzero(mask))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#pixelpoints = cv2.findNonZero(mask)</span></span></pre></td></tr></table></figure>
<p>这里我们是用来两种方法，第一种方法使用了$Numpy$ 函数，第二种使用了$OpenCV$ 函数。结果相同，但还是有点不同。$Numpy$ 给出的坐标是$(row,column)$形式的。而OpenCV 给出的格式是$(x,y)$形式的。所以这两个结果基本是可以互换的。$row=x，column=y$。</p>
<h5 id="最大值和最小值及它们的位置"><a href="#最大值和最小值及它们的位置" class="headerlink" title="最大值和最小值及它们的位置"></a>最大值和最小值及它们的位置</h5><p>​        我们可以使用掩模图像得到这些参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(imgray,mask = mask)</span></pre></td></tr></table></figure>
<h5 id="平均颜色及平均灰度"><a href="#平均颜色及平均灰度" class="headerlink" title="平均颜色及平均灰度"></a>平均颜色及平均灰度</h5><p>​        我们也可以使用相同的掩模求一个对象的平均颜色或平均灰度。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">mean_val = cv2.mean(im,mask = mask)</span></pre></td></tr></table></figure>
<h5 id="极点"><a href="#极点" class="headerlink" title="极点"></a>极点</h5><p>​        一个对象最上面，最下面，最左边，最右边的点。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">leftmost = tuple(cnt[cnt[:,:,<span class="number">0</span>].argmin()][<span class="number">0</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">rightmost = tuple(cnt[cnt[:,:,<span class="number">0</span>].argmax()][<span class="number">0</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">topmost = tuple(cnt[cnt[:,:,<span class="number">1</span>].argmin()][<span class="number">0</span>])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">bottommost = tuple(cnt[cnt[:,:,<span class="number">1</span>].argmax()][<span class="number">0</span>])</span></pre></td></tr></table></figure>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        
<span class="post-time">
    Last updated: <time datetime="2021-04-16T17:24:28.510Z" itemprop="dateUpdated">2021-04-17 01:24:28</time>
</span><br>


        
        这里可以写作者留言，标签和 hexo 中所有变量及辅助函数等均可调用，示例：<a href="/2020/03/20/opencv/" target="_blank" rel="external">https://pllj.github.io/2020/03/20/opencv/</a>
        
    </div>
    
    <footer>
        <a href="https://pllj.github.io">
            <img src="/img/main.jpg" alt="Zhu Junchao">
            Zhu Junchao
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/OpenCV/" rel="tag">OpenCV</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://pllj.github.io/2020/03/20/opencv/&title=《OpenCV入门笔记》 — Zhu Junchao's Blog&pic=https://pllj.github.io/img/main.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" target="_blank" rel="noopener" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://pllj.github.io/2020/03/20/opencv/&title=《OpenCV入门笔记》 — Zhu Junchao's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://pllj.github.io/2020/03/20/opencv/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《OpenCV入门笔记》 — Zhu Junchao's Blog&url=https://pllj.github.io/2020/03/20/opencv/&via=https://pllj.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://pllj.github.io/2020/03/20/opencv/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" target="_self" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2021/04/17/CF1511E/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">CF1511 E. Colorings and Dominoes</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/02/29/UCFLPC2015/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">UCF Local Programming Contest 2015</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
    <div class="top">
        
<p>
    <span id="busuanzi_container_site_uv" style='display:none'>
        站点总访客数：<span id="busuanzi_value_site_uv"></span>
    </span>
    <span id="busuanzi_container_site_pv" style='display:none'>
        站点总访问量：<span id="busuanzi_value_site_pv"></span>
    </span>
</p>


        <p>
            
            <span>This blog is licensed under a <a rel="license noopener" href="https://creativecommons.org/licenses/by/4.0/" target="_blank">Creative Commons Attribution 4.0 International License</a>.</span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Zhu Junchao &copy; 2019 - 2021</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" target="_self" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://pllj.github.io/2020/03/20/opencv/&title=《OpenCV入门笔记》 — Zhu Junchao's Blog&pic=https://pllj.github.io/img/main.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" target="_blank" rel="noopener" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://pllj.github.io/2020/03/20/opencv/&title=《OpenCV入门笔记》 — Zhu Junchao's Blog&source=" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://pllj.github.io/2020/03/20/opencv/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《OpenCV入门笔记》 — Zhu Junchao's Blog&url=https://pllj.github.io/2020/03/20/opencv/&via=https://pllj.github.io" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://pllj.github.io/2020/03/20/opencv/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;" target="_blank" rel="noopener"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://pllj.github.io/2020/03/20/opencv/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>



<!-- mathjax config similar to math.stackexchange -->

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
});
</script>

<script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" async></script>




<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>



<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '人呢！';
            clearTimeout(titleTime);
        } else {
            document.title = '(つェ⊂)咦!又回来了!';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>


<script src="//pllj.github.io/js/my.js"></script>
</body>
</html>
